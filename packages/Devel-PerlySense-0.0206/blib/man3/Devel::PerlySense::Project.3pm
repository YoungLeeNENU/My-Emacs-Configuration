.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::PerlySense::Project 3pm"
.TH Devel::PerlySense::Project 3pm "2012-12-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::PerlySense::Project \- A Project root
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Project describes the root directory of a source tree.
.PP
A Project has configuration settings.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
.SS "dirProject"
.IX Subsection "dirProject"
The effective project root dir.
.PP
Readonly.
.SS "dirProjectExplicitDir"
.IX Subsection "dirProjectExplicitDir"
If known, the root dir made explicit by the existence of a project
directory and config, else ""
.PP
Default: ""
.SS "dirProjectImplicitUse"
.IX Subsection "dirProjectImplicitUse"
If known, the root dir indicated by a found used module, else "".
.PP
Default: ""
.SS "dirProjectImplicitDir"
.IX Subsection "dirProjectImplicitDir"
If known, the root dir indicated by the presence of \*(L"lib\*(R" or \*(L"t\*(R", else "".
.PP
Default: ""
.SS "oConfig"
.IX Subsection "oConfig"
A Config::Project object with the current Project Config. This gets
loaded if there is a config file available when the Project is
identified.
.PP
Default: An Config::Project::Default object
.SS "rhConfig"
.IX Subsection "rhConfig"
The actual hashref with config values.
.PP
Readonly (that includes the entire data structure).
.SS "oPerlySense"
.IX Subsection "oPerlySense"
Devel::PerlySense object.
.SS "nameVcs"
.IX Subsection "nameVcs"
The name of the Version Control system for the project.
.PP
Readonly. Currently supported:
.PP
.Vb 3
\&  git
\&  svn
\&  none
.Ve
.PP
In that order, so that if there's a Git repo on top of a \s-1SVN\s0 repo, git
is found.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.ie n .SS "newFromLocation(file => $file, dir => $dir, oPerlySense => $oPs)"
.el .SS "newFromLocation(file => \f(CW$file\fP, dir => \f(CW$dir\fP, oPerlySense => \f(CW$oPs\fP)"
.IX Subsection "newFromLocation(file => $file, dir => $dir, oPerlySense => $oPs)"
Create new Project given either \f(CW$file\fR, or \f(CW$dir\fR.
.PP
First, search for an explicit project root directory, then try to find
any modules used in \f(CW$file\fR (if passed), then try to find any \*(L"lib\*(R" or
\&\*(L"t\*(R" directory upwards of \f(CW$file\fR or \f(CW$dir\fR.
.PP
\&\f(CW$file\fR takes precedence over \f(CW$dir\fR if both are specified.
.PP
If none if this works out, no Project can be created and undef is
returned.
.PP
Return the new object, or undef if no project could be found.
.ie n .SS "newFindExplicit(dir => $dir, oPerlySense => $oPs)"
.el .SS "newFindExplicit(dir => \f(CW$dir\fP, oPerlySense => \f(CW$oPs\fP)"
.IX Subsection "newFindExplicit(dir => $dir, oPerlySense => $oPs)"
Create new Project if there is an explicit .PerlySenseProject
directory in the path above \f(CW$dir\fR.
.PP
Return the new object, or undef if no project could be found.
.SH "MEHTODS"
.IX Header "MEHTODS"
.ie n .SS "rhRunFile(file => $fileSource, [rhConfigType = \s-1DEDUCED_FROM_FILE\s0], [ keyConfigCommand = ""command"" ])"
.el .SS "rhRunFile(file => \f(CW$fileSource\fP, [rhConfigType = \s-1DEDUCED_FROM_FILE\s0], [ keyConfigCommand = ``command'' ])"
.IX Subsection "rhRunFile(file => $fileSource, [rhConfigType = DEDUCED_FROM_FILE], [ keyConfigCommand = command ])"
Like rhRunFile0, but with what => \*(L"run\*(R".
.ie n .SS "rhDebugFile(file => $fileSource, [rhConfigType = \s-1DEDUCED_FROM_FILE\s0], [ keyConfigCommand = ""command"" ])"
.el .SS "rhDebugFile(file => \f(CW$fileSource\fP, [rhConfigType = \s-1DEDUCED_FROM_FILE\s0], [ keyConfigCommand = ``command'' ])"
.IX Subsection "rhDebugFile(file => $fileSource, [rhConfigType = DEDUCED_FROM_FILE], [ keyConfigCommand = command ])"
Like rhRunFile0, but with what => \*(L"debug\*(R".
.ie n .SS "rhRunFile0(file => $fileSource, what => ""run"" | ""debug"", [rhConfigType = \s-1DEDUCED_FROM_FILE\s0], [ keyConfigCommand = ""command"" ])"
.el .SS "rhRunFile0(file => \f(CW$fileSource\fP, what => ``run'' | ``debug'', [rhConfigType = \s-1DEDUCED_FROM_FILE\s0], [ keyConfigCommand = ``command'' ])"
.IX Subsection "rhRunFile0(file => $fileSource, what => run | debug, [rhConfigType = DEDUCED_FROM_FILE], [ keyConfigCommand = command ])"
Figure out what type of source file \f(CW$fileSource\fR is, and how it should
be run/debugged.
.PP
The settings in the global config\->{$what_file} is used to determine
the details.
.PP
The command to use is taken from
config\->{$what_file}\->{$keyConfigCommand}, if that is specified,
otherwise for \*(L"command\*(R".
.PP
Return hash ref with (keys: \*(L"dir_$what_from\*(R", \*(L"command_$what\*(R",
\&\*(L"type_source_file\*(R"), or die on errors (like if no Project could be
found).
.PP
dir_$what_from is an absolute directory name which should be the cwd
when command_$what is executed.
.PP
type_source_file is something like \*(L"Test\*(R", \*(L"Module\*(R".
.ie n .SS "rhConfigTypeForFile(file => $fileSource, keyConfig => \s-1CONFIG_KEY\s0)"
.el .SS "rhConfigTypeForFile(file => \f(CW$fileSource\fP, keyConfig => \s-1CONFIG_KEY\s0)"
.IX Subsection "rhConfigTypeForFile(file => $fileSource, keyConfig => CONFIG_KEY)"
Return the config type hash ref (keys: command, moniker) from the ones
available in the config. Match the \f(CW$fileSource\fR name against each rex
in the config.
.PP
Die if no configType could be identified.
.ie n .SS "aDirIncProject(dirRelativeTo => $dirRelativeTo)"
.el .SS "aDirIncProject(dirRelativeTo => \f(CW$dirRelativeTo\fP)"
.IX Subsection "aDirIncProject(dirRelativeTo => $dirRelativeTo)"
Return array with dir objects which are the inc_dir directories in the
config, plus the usual inc directories. They are all relative to
\&\f(CW$dirRelativeTo\fR.
.SS "\fIaDirIncAbsolute()\fP"
.IX Subsection "aDirIncAbsolute()"
Return array with absolute dir objects which are the inc_dir
directories in the config, plus the usual inc directories.
.ie n .SS "isFileInProject(file => $file)"
.el .SS "isFileInProject(file => \f(CW$file\fP)"
.IX Subsection "isFileInProject(file => $file)"
Return true if \f(CW$file\fR is within the project root, or in any of the \s-1INC\s0
directories, else false. Die on errors.
.PP
Test logically/structurally, not whether the file actually exists.
.ie n .SS "flymakeFile(file => $fileSource)"
.el .SS "flymakeFile(file => \f(CW$fileSource\fP)"
.IX Subsection "flymakeFile(file => $fileSource)"
Do a flymake run with \f(CW$fileSource\fR according to the flymake config and
output the result to \s-1STDOUT\s0 and \s-1STDERR\s0.
.PP
Return 1 or die on errors (but that will look like the result of a
failed flymake run).
.ie n .SS "rhSubCovered(file => $fileSource)"
.el .SS "rhSubCovered(file => \f(CW$fileSource\fP)"
.IX Subsection "rhSubCovered(file => $fileSource)"
Do a \*(L"covered subs\*(R" call with \f(CW$fileSource\fR.
.PP
Die if Devel::CoverX::Covered isn't installed.
.PP
Return hash ref with (keys: sub name; values: quality)), or an empty
hash ref if no coverage info was found for \f(CW$fileSource\fR.
.PP
Any subs with the same name will have their qualities combined.
.ie n .SS "raFileTestOther(file => $fileSource, [sub => $sub])"
.el .SS "raFileTestOther(file => \f(CW$fileSource\fP, [sub => \f(CW$sub\fP])"
.IX Subsection "raFileTestOther(file => $fileSource, [sub => $sub])"
Return array ref with file names of files related to \f(CW$file\fR and
possibly \f(CW$sub\fR, i.e. the \*(L"other\*(R" files related \f(CW$file\fR.
.PP
If \f(CW$file\fR is a source file, return test files, and vice verca.
.PP
\&\f(CW$sub\fR is only ever active when \f(CW$fileSource\fR is a source file.
.PP
Die if Devel::CoverX::Covered isn't installed.
.ie n .SS "raFileProjectOther(file => $fileSource, [sub => $sub])"
.el .SS "raFileProjectOther(file => \f(CW$fileSource\fP, [sub => \f(CW$sub\fP])"
.IX Subsection "raFileProjectOther(file => $fileSource, [sub => $sub])"
Return array ref with file names of files corresponding to \f(CW$file\fR.
.PP
Die if there is no config file.
.SH "AUTHOR"
.IX Header "AUTHOR"
Johan Lindstro\*:m, \f(CW\*(C`<johanl[A\*:T]DarSerMan.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-devel\-perlysense@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel\-PerlySense <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel-PerlySense>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2005 Johan Lindstro\*:m, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
