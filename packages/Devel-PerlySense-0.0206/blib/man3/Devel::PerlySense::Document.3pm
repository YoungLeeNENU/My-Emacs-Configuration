.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::PerlySense::Document 3pm"
.TH Devel::PerlySense::Document 3pm "2012-12-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::PerlySense::Document \- A Perl file/document
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The document contains a \s-1PPI\s0 parsed document, etc. along with a
metadata object.
.SS "Caching"
.IX Subsection "Caching"
Caching is done on a per file + mod timestamp basis. Things that are
cached are: \s-1PPI\s0 documents, Document::Api and Document::Meta objects.
.PP
Currently Cache::Cache is used. This isn't great (duh), since there is
no good way to expire obsolete files.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
.SS "oPerlySense"
.IX Subsection "oPerlySense"
Devel::PerlySense object.
.PP
Default: set during \fInew()\fR
.SS "file"
.IX Subsection "file"
The absolute file name of the parsed file, or "" if none was parsed.
.PP
Default: ""
.SS "oDocument"
.IX Subsection "oDocument"
The PPI::Document object from the \fIparse()\fR, or undef if none was
parsed.
.PP
Default: undef
.SS "oMeta"
.IX Subsection "oMeta"
The Devel::PerlySense::Document::Meta object from the \fIparse()\fR, or
undef if none was parsed.
.PP
Default: undef
.SS "rhPackageApiLikely"
.IX Subsection "rhPackageApiLikely"
Hash ref with (keys: package names; Document::Api objects).
.PP
Default: {}
.SH "API METHODS"
.IX Header "API METHODS"
.ie n .SS "new(oPerlySense => $oPerlySense)"
.el .SS "new(oPerlySense => \f(CW$oPerlySense\fP)"
.IX Subsection "new(oPerlySense => $oPerlySense)"
Create new PearlySense::Document object. Associate it with \f(CW$oPerlySense\fR.
.ie n .SS "fileFindModule(nameModule => $nameModule)"
.el .SS "fileFindModule(nameModule => \f(CW$nameModule\fP)"
.IX Subsection "fileFindModule(nameModule => $nameModule)"
Find the file containing the \f(CW$nameModule\fR given the file property of
the document.
.PP
Return the absolute file name, or undef if none could be found. Die on
errors.
.ie n .SS "parse(file => $file)"
.el .SS "parse(file => \f(CW$file\fP)"
.IX Subsection "parse(file => $file)"
Parse the \f(CW$file\fR and store the metadata.
.PP
Return 1 on success, else die.
.PP
Cached on the usual.
.ie n .SS "parse0(file => $file)"
.el .SS "parse0(file => \f(CW$file\fP)"
.IX Subsection "parse0(file => $file)"
Parse the \f(CW$file\fR and store the metadata.
.PP
Return 1 on success, else die.
.SS "\fIaNamePackage()\fP"
.IX Subsection "aNamePackage()"
Return list of package names in this document.
.SS "\fIaNameBase()\fP"
.IX Subsection "aNameBase()"
Return list of names of modules that are base classes, according to
either \*(L"use base\*(R" or an assignment to \f(CW@ISA\fR.
.PP
Dir on errors.
.SS "hasBaseClass($nameClass)"
.IX Subsection "hasBaseClass($nameClass)"
Return true if \f(CW$nameClass\fR is an immediate base class to this one, else
false.
.SS "\fIaNameModuleUse()\fP"
.IX Subsection "aNameModuleUse()"
Find modules that are used in this document.
.PP
Don't find pragmas. Don't find very common infrastructure
modules. Only report modules used in this actual document.
.PP
Return list of unique module names.
.PP
Dir on errors.
.ie n .SS "packageAt(row => $row)"
.el .SS "packageAt(row => \f(CW$row\fP)"
.IX Subsection "packageAt(row => $row)"
Return the package name that is active on line \f(CW$row\fR (1..), or die on
errors.
.ie n .SS "isEmptyAt(row => $row, col => $col)"
.el .SS "isEmptyAt(row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "isEmptyAt(row => $row, col => $col)"
Determine whether the position at \f(CW$row\fR, \f(CW$col\fR is empty (ther is no known
content, no:
.PP
.Vb 3
\&  modules
\&  methods
\&  variables?
.Ve
.PP
).
.PP
Return 1 if empty, else 0.
.PP
Die on errors.
.ie n .SS "moduleAt(row => $row, col => $col)"
.el .SS "moduleAt(row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "moduleAt(row => $row, col => $col)"
Find the module mentioned on line \f(CW$row\fR (1..) at \f(CW$col\fR (1..). Don't
recognize modules that isn't \fIucfirst()\fR. There may be false positives,
if it looks like a module. (examples?)
.PP
Return string like \*(L"My::Module\*(R" or \*(L"Module\*(R", or undef if none was
found.
.PP
Die on errors.
.ie n .SS "methodCallAt(row => $row, col => $col)"
.el .SS "methodCallAt(row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "methodCallAt(row => $row, col => $col)"
Return the method call Perl code is on line \f(CW$row\fR (1..) at \f(CW$col\fR (1..),
or die on errors.
.PP
In scalar context, return string like \*(L"$self\->fooBar\*(R". Don't include
the parameter list or parens, only the \*(L"$object\->method\*(R".
.PP
In list context, return two item list with (object, method).
.PP
The object may be undef/"" if it's an expression rather than a simple
variable.
.PP
Return undef or () if none was found. Die on errors.
.ie n .SS "selfMethodCallAt(row => $row, row => $col)"
.el .SS "selfMethodCallAt(row => \f(CW$row\fP, row => \f(CW$col\fP)"
.IX Subsection "selfMethodCallAt(row => $row, row => $col)"
Return the name of the \f(CW$self\fR\->method at \f(CW$row\fR, \f(CW$col\fR in this document.
.PP
If no method call is found, maybe warn and return undef.
.PP
Die on errors.
.ie n .SS "moduleMethodCallAt(row => $row, row => $col)"
.el .SS "moduleMethodCallAt(row => \f(CW$row\fP, row => \f(CW$col\fP)"
.IX Subsection "moduleMethodCallAt(row => $row, row => $col)"
Find the My::Module\->method call at \f(CW$row\fR, \f(CW$col\fR in this document.
.PP
In list context, return two item list with (module, method). In scalar
context, return \*(L"My::Module\->method\*(R".
.PP
Return undef or () if none was found. Die on errors.
.ie n .SS "aObjectMethodCallAt(row => $row, row => $col)"
.el .SS "aObjectMethodCallAt(row => \f(CW$row\fP, row => \f(CW$col\fP)"
.IX Subsection "aObjectMethodCallAt(row => $row, row => $col)"
Return three item array with (object name, method name, \f(CW$oLocation\fR of the
surrounding sub) of the \f(CW$self\fR\->method at \f(CW$row\fR, \f(CW$col\fR in this
document. The object may be '$self'.
.PP
If no method call is found, maybe warn and return ().
.PP
Die on errors.
.ie n .SS "rhRegexExample(row => $row, col => $col)"
.el .SS "rhRegexExample(row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "rhRegexExample(row => $row, col => $col)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and find the regex located there,
and possibly the example comment preceeding it.
.PP
Return hash ref with (keys: regex, example; values: source
string). The source string is an empty string if nothing found.
.PP
If there is an example string in a comment, return the example without
the comment #
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "oLocationSub(name => $name, [package => ""main""])"
.el .SS "oLocationSub(name => \f(CW$name\fP, [package => ``main''])"
.IX Subsection "oLocationSub(name => $name, [package => main])"
Return a Devel::PerlySense::Document::Location object with the
location of the sub declaration called \f(CW$name\fR in \f(CW$package\fR, or undef if
it wasn't found.
.PP
Die on errors.
.ie n .SS "oLocationSubAt(row => $row, col => $col)"
.el .SS "oLocationSubAt(row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "oLocationSubAt(row => $row, col => $col)"
Return a Devel::PerlySense::Document::Location object with the
location of the sub definition at \f(CW$row\fR/$col, or undef if it row/col
isn't inside a sub definition.
.PP
Note: Currently, col is ignored, and the sub is presumed to occupy the
entire row.
.PP
Die on errors.
.ie n .SS "oLocationSubDefinition(name => $name, [row => $row], [package => $package])"
.el .SS "oLocationSubDefinition(name => \f(CW$name\fP, [row => \f(CW$row\fP], [package => \f(CW$package\fP])"
.IX Subsection "oLocationSubDefinition(name => $name, [row => $row], [package => $package])"
Return a Devel::PerlySense::Document::Location object with the
location of the sub \*(L"definition\*(R" for \f(CW$name\fR, or undef if it wasn't
found. The definition can be the sub declaration, or a \s-1POD\s0 entry.
.PP
If \f(CW$row\fR is passed, use it to determine which package is active at
\&\f(CW$row\fR. If \f(CW$package\fR is passed, use that instead. Default to package
\&\*(L"main\*(R" if neither is passed.
.PP
If no definition can be found in this document, and the module has one
or more base classes, look in the \f(CW@ISA\fR (depth-first, just like Perl
(see perldoc perltoot)).
.PP
Warn on some failures to find the location. Die on errors.
.ie n .SS "oLocationPod(name => $name, lookFor => $lookFor, [ignoreBaseModules => 0])"
.el .SS "oLocationPod(name => \f(CW$name\fP, lookFor => \f(CW$lookFor\fP, [ignoreBaseModules => 0])"
.IX Subsection "oLocationPod(name => $name, lookFor => $lookFor, [ignoreBaseModules => 0])"
Return a Devel::PerlySense::Document::Location object with the \*(L"best\*(R"
location of the pod =head? or =item where \f(CW$name\fR is present, or undef
if it wasn't found.
.PP
\&\f(CW$lookFor\fR can be \*(L"method\*(R", i.e. what the search was looking for.
.PP
If \f(CW$lookFor\fR is \*(L"method\*(R" and the \s-1POD\s0 isn't found, try in the base
classes, unless \f(CW$ignoreBaseModules\fR is true.
.PP
If the method \s-1POD\s0 is found in a base class, make sure that notice is
in the rhProperty\->{pod} (once).
.PP
Set the rhProperty keys of the Location:
.PP
.Vb 5
\&  found \- $lookFor
\&  docType \- "hint"
\&  name \- the $name
\&  pod \- the POD describing $name (includes podSection)
\&  podSection \- the POD section the name is located in
.Ve
.PP
pod will be munged to include podSection, and if the original pod
consisted of an \*(L"=item\*(R", it will be surrounded by \*(L"=over\*(R" 4 and
\&\*(L"=back\*(R".
.PP
Die on errors.
.ie n .SS "aMethodCallOf(nameObject => $nameObject, oLocationWithin => $oLocationWithin)"
.el .SS "aMethodCallOf(nameObject => \f(CW$nameObject\fP, oLocationWithin => \f(CW$oLocationWithin\fP)"
.IX Subsection "aMethodCallOf(nameObject => $nameObject, oLocationWithin => $oLocationWithin)"
Find all the method calls of \f(CW$nameObject\fR in the \f(CW$oLocationWithin\fR.
.PP
Shortcut: assume the \f(CW$oLocationWithin\fR is the entire interesting
scope. Ignore morons who re-define their vars in inner scopes with a
different type. If this turns out to be a problem, fix the problem
then. Or smack them over the head with a trout.
.PP
Return sorted array with the method names called.
.PP
Die on errors.
.ie n .SS "determineLikelyApi(nameModule => $nameModule)"
.el .SS "determineLikelyApi(nameModule => \f(CW$nameModule\fP)"
.IX Subsection "determineLikelyApi(nameModule => $nameModule)"
Look in the document for sub declarations, \f(CW$self\fR\->method calls, and
\&\f(CW$self\fR\->{hash_key} in order to determine what is the likely \s-1API\s0 of the
packages of this document. Focus on the \f(CW$nameModule\fR and its base
classes.
.PP
Set the rhPackageApiLikely property with new
Devel::PerlySense::Document::Api objects for each package.
.PP
Return 1 on success. Die on errors.
.PP
Cached on the usual + \f(CW$nameModule\fR.
.ie n .SS "determineLikelyApi0(nameModule => $nameModule)"
.el .SS "determineLikelyApi0(nameModule => \f(CW$nameModule\fP)"
.IX Subsection "determineLikelyApi0(nameModule => $nameModule)"
Implementation for \fIdetermineLikelyApi()\fR
.ie n .SS "mergePackageApiWithBase(nameModule => $nameModule, rhPackageApi => $rhPackageApi, nameModuleBase => $nameModuleBase, rhPackageApiBase => $rhPackageApiBase)"
.el .SS "mergePackageApiWithBase(nameModule => \f(CW$nameModule\fP, rhPackageApi => \f(CW$rhPackageApi\fP, nameModuleBase => \f(CW$nameModuleBase\fP, rhPackageApiBase => \f(CW$rhPackageApiBase\fP)"
.IX Subsection "mergePackageApiWithBase(nameModule => $nameModule, rhPackageApi => $rhPackageApi, nameModuleBase => $nameModuleBase, rhPackageApiBase => $rhPackageApiBase)"
Merge the \f(CW$rhPackageApiBase\fR of the base class with the existing
\&\f(CW$rhPackageApi\fR. Modify \f(CW$rhPackageApi\fR.
.PP
Only merge the \s-1API\s0 of the \f(CW$nameModule\fR.
.PP
Document::Api objects are cloned, not reused, but individual
Document::Location objects may be shared between documents and apis.
.PP
Return 1 on success, or 0 if the package wasn't found. Die on errors.
.ie n .SS "scoreInterfaceMatch(nameModule => $nameModule, raMethodRequired => $raMethodRequired, raMethodNice => $raMethodNice)"
.el .SS "scoreInterfaceMatch(nameModule => \f(CW$nameModule\fP, raMethodRequired => \f(CW$raMethodRequired\fP, raMethodNice => \f(CW$raMethodNice\fP)"
.IX Subsection "scoreInterfaceMatch(nameModule => $nameModule, raMethodRequired => $raMethodRequired, raMethodNice => $raMethodNice)"
Rate the interface match between the document and the wanted interface
of the method names in \f(CW$raMethodRequired\fR + \f(CW$raMethodNice\fR.
.PP
If not all method names in \f(CW$raMethodRequired\fR are supported, the score
is 0, and this document should not be considered to support the
requirements.
.PP
The score is calculated like this:
.PP
.Vb 2
\& % of ($raMethod*) that is supported, except
\& all required must be there.
\&
\& +
\&
\& % of the api that consists of $raMethod*. This will favour smaller
\& interfaces in base classes.
.Ve
.PP
Return score on success. Die on errors.
.SS "\fIstringSignatureSurveyFromFile()\fP"
.IX Subsection "stringSignatureSurveyFromFile()"
Calculate a Signature Survey string for the source in the document.
.PP
Return the string. Die on errors.
.SS "stringSignatureSurveyFromSource($stringSource)"
.IX Subsection "stringSignatureSurveyFromSource($stringSource)"
Calculate a Signature Survey string for the \f(CW$stringSource\fR, based on
the idea in http://c2.com/doc/SignatureSurvey/ .
.PP
The idea is not to get an exact representation of the source but a
good feel for what it contains.
.PP
Return the survey string. Die on errors.
.SH "IMPLEMENTATION METHODS"
.IX Header "IMPLEMENTATION METHODS"
.ie n .SS "oLocationOfNode($oNode, [$extraRow = 0, $extraCol = 0])"
.el .SS "oLocationOfNode($oNode, [$extraRow = 0, \f(CW$extraCol\fP = 0])"
.IX Subsection "oLocationOfNode($oNode, [$extraRow = 0, $extraCol = 0])"
Return Devel::PerlySense::Document::Location object for \f(CW$oNode\fR.
.PP
If \f(CW$extraRow\fR or \f(CW$extraCol\fR are passed, add that to the location.
.SS "aDocumentFind($what)"
.IX Subsection "aDocumentFind($what)"
Convenience wrapper around \f(CW$self\fR\->$oDocument\->find($what) to account
for the unusable api.
.PP
Return list of matching nodes, or an empty list if none was found.
.ie n .SS "aNodeFind($oNode, $what)"
.el .SS "aNodeFind($oNode, \f(CW$what\fP)"
.IX Subsection "aNodeFind($oNode, $what)"
Convenience wrapper around \f(CW$oNode\fR\->find($what) to account
for the unusable api.
.PP
Return list of matching nodes, or an empty list if none was found.
.SS "oLocationEnclosingSub($oNode)"
.IX Subsection "oLocationEnclosingSub($oNode)"
Return a Document::Location object that is the enclosing sub of
\&\f(CW$oNode\fR, i.e. \f(CW$oNode\fR is located within the sub block. The Location
object has the following rhProperty keys:
.PP
.Vb 3
\&  nameSub
\&  source
\&  oLocationEnd with: row and col
.Ve
.PP
Return Location object with the sub, or undef if none was found. Die on
errors.
.SH "CACHE METHODS"
.IX Header "CACHE METHODS"
.ie n .SS "cacheSet($key, $file, $rValue)"
.el .SS "cacheSet($key, \f(CW$file\fP, \f(CW$rValue\fP)"
.IX Subsection "cacheSet($key, $file, $rValue)"
If a cache is active, store the \f(CW$value\fR in the cache under the total
key of ($file, \f(CW$file\fR's timestamp, \f(CW$key\fR).
.PP
\&\f(CW$value\fR should be a scalar or reference which can be freezed.
.PP
\&\f(CW$file\fR must be an existing file.
.PP
Return 1 if the \f(CW$value\fR was stored, else 0. Die on errors.
.ie n .SS "cacheGet($key, $file)"
.el .SS "cacheGet($key, \f(CW$file\fP)"
.IX Subsection "cacheGet($key, $file)"
If a cache is active, get the value in the cache under the total key
of ($file, \f(CW$file\fR's timestamp, \f(CW$key\fR).
.PP
\&\f(CW$file\fR must be an existing file.
.PP
Return the value, or undef if the value could not be fetched. Die on
errors.
.SH "AUTHOR"
.IX Header "AUTHOR"
Johan Lindstro\*:m, \f(CW\*(C`<johanl[A\*:T]DarSerMan.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-devel\-perlysense@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel\-PerlySense <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel-PerlySense>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2005 Johan Lindstro\*:m, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
