.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::PerlySense::Class 3pm"
.TH Devel::PerlySense::Class 3pm "2012-12-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::PerlySense::Class \- A Perl Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A Perl Class is a Perl Package with an \s-1OO\s0 interface.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
.SS "oPerlySense"
.IX Subsection "oPerlySense"
Devel::PerlySense object.
.PP
Default: set during \fInew()\fR
.SS "name"
.IX Subsection "name"
The Class name (i.e. the package name)
.PP
Default: ""
.SS "raDocument"
.IX Subsection "raDocument"
Array ref with PerlySense::Document objects that define this class.
.PP
Default: []
.SS "rhClassBase"
.IX Subsection "rhClassBase"
Hash ref with (keys: base class names; values: base class
PerlySense::Class objects).
.PP
Default: {}
.SH "API METHODS"
.IX Header "API METHODS"
.SS "new(oPerlySense, name, raDocument, rhClassSeen => {})"
.IX Subsection "new(oPerlySense, name, raDocument, rhClassSeen => {})"
Create new PerlySense::Class object. Give it \f(CW$name\fR and associate it
with \f(CW$oPerlySense\fR.
.PP
\&\f(CW$rhClassSeen\fR is used to keep track of seen base classes in case we
encounter circular deps.
.ie n .SS "newFromFileAt(oPerlySense => $oPerlySense, file => $file, row => $row, col => $col)"
.el .SS "newFromFileAt(oPerlySense => \f(CW$oPerlySense\fP, file => \f(CW$file\fP, row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "newFromFileAt(oPerlySense => $oPerlySense, file => $file, row => $row, col => $col)"
Create new PerlySense::Class object given the class found at \f(CW$row\fR,
\&\f(CW$col\fR in \f(CW$file\fR.
.PP
If there was no package started yet at \f(CW$row\fR, \f(CW$col\fR, but there is one
later in the file, use the first one instead (this is when you're at
the top of the file and the package statement didn't happen yet).
.PP
Return new object, or undef if no class was found, or die if the file
doesn't exist.
.SS "newFromName(oPerlySense, name, dirOrigin, rhClassSeen)"
.IX Subsection "newFromName(oPerlySense, name, dirOrigin, rhClassSeen)"
Create new PerlySense::Class object given the class \f(CW$name\fR.
.PP
Look for the module file starting at \f(CW$dirOrigin\fR.
.PP
Return new object, or undef if no class was found with that \f(CW$name\fR.
.SS "findBaseClasses(rhClassSeen)"
.IX Subsection "findBaseClasses(rhClassSeen)"
Find the base classes of this class and set (replace) rBaseClass with
newly created Class objects.
.PP
Reuse any class names and objects in \f(CW$rhClassSeen\fR (keys: class names;
values: Class objects), i.e. don't follow them upwards, they have
already been taken care of.
.SS "\fIrhClassSub()\fP"
.IX Subsection "rhClassSub()"
Find the sub classes of this class and return a hash ref with (keys:
Class names; values: Class objects).
.PP
Look for subclasses in the directory of this Class, and below.
.PP
(In the future, look in all of the current project.)
.PP
(this is a horribly inefficient way of finding subclasses. When there
is Project with metadata, use that instead of looking everywhere).
.SS "\fIrhDirNameClassInNeighbourhood()\fP"
.IX Subsection "rhDirNameClassInNeighbourhood()"
Find the classes in the neighbourhood of this class and return a hash
ref with (keys: up, current, down; values: array refs with (Package names).
.ie n .SS "aNameClassInDir(dir => $dir)"
.el .SS "aNameClassInDir(dir => \f(CW$dir\fP)"
.IX Subsection "aNameClassInDir(dir => $dir)"
Find the classes names in the .pm files in \f(CW$dir\fR and return a list of
Class names.
.SS "\fIaNameModuleUse()\fP"
.IX Subsection "aNameModuleUse()"
Return array with the names of the \*(L"use \s-1MODULE\s0\*(R" modules in the Class.
.SS "\fIaBookmarkMatchResult()\fP"
.IX Subsection "aBookmarkMatchResult()"
Return array of Bookmark::MatchResult objects that matches the current
source.
.SS "\fIdirModule()\fP"
.IX Subsection "dirModule()"
Return the base dir for this class, i.e. the dir in which the main .pm
file is in.
.ie n .SS "oLocationMethodDoc(method => $method)"
.el .SS "oLocationMethodDoc(method => \f(CW$method\fP)"
.IX Subsection "oLocationMethodDoc(method => $method)"
Find the docs for the \f(CW$method\fR name and return a Location object
similar to PerlySense\->oLocationMethodDocFromDocument, or undef if no
doc could be found.
.PP
Die on errors.
.ie n .SS "oLocationMethodGoTo(method => $method)"
.el .SS "oLocationMethodGoTo(method => \f(CW$method\fP)"
.IX Subsection "oLocationMethodGoTo(method => $method)"
Find the declaration for the \f(CW$method\fR name and return a Location object
similar to PerlySense\->oLocationSubDefinitionFromDocument, or undef if no
declaration could be found.
.PP
Die on errors.
.ie n .SS "oLocationSubAt(row => $row, col => $col)"
.el .SS "oLocationSubAt(row => \f(CW$row\fP, col => \f(CW$col\fP)"
.IX Subsection "oLocationSubAt(row => $row, col => $col)"
Return a Devel::PerlySense::Document::Location object with the
location of the sub definition at \f(CW$row\fR/$col, or undef if it row/col
isn't inside a sub definition.
.PP
Die on errors.
.ie n .SS "oLocationSub(name => $name)"
.el .SS "oLocationSub(name => \f(CW$name\fP)"
.IX Subsection "oLocationSub(name => $name)"
Return a Devel::PerlySense::Document::Location object with the
location of the sub declaration called \f(CW$name\fR, or undef if it wasn't
found.
.PP
Die on errors.
.SH "AUTHOR"
.IX Header "AUTHOR"
Johan Lindstro\*:m, \f(CW\*(C`<johanl[A\*:T]DarSerMan.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-devel\-perlysense@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel\-PerlySense <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel-PerlySense>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2005 Johan Lindstro\*:m, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
