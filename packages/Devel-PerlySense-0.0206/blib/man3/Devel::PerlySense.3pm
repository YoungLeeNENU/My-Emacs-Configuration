.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::PerlySense 3pm"
.TH Devel::PerlySense 3pm "2012-12-21" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::PerlySense \- Perl IDE backend with Emacs frontend
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PerlySense is a Perl \s-1IDE\s0 backend that integrates with editor
frontends, currently Emacs.
.PP
(While no one has written a Vim frontend, PerlySense can emit Vim
style data structures.)
.PP
Conveniently navigate and browse the code and documentation of your
project and Perl installation. Navigate between tests and source, and
between related files.
.PP
Search through the project for method declarations, invocants or free
text using Ack.
.PP
Run tests and scripts with easy navigation to errors/warnings/failing
tests.
.PP
Automate common editing tasks related to source code, tests, regular
expressions, etc.
.PP
Highlight syntax errors, warnings, Perl::Critic complaints, and
Devel::Cover test coverage in the source while editing.
.PP
PerlySense has a plugin system for understanding custom syntax,
e.g. Moose.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "From Emacs"
.IX Subsection "From Emacs"
\&\fBOverview\fR \*(-- \f(CW\*(C`C\-o C\-o\*(C'\fR \*(-- Show information about the Class at point
or the current Class. There are also shortcuts to show a single
section:
.IP "\(bu" 4
C\-o o i \*(-- Inheritance
.IP "\(bu" 4
C\-o o a \*(-- \s-1API\s0
.IP "\(bu" 4
C\-o o b \*(-- Bookmarks
.IP "\(bu" 4
C\-o o u \*(-- Uses
.IP "\(bu" 4
C\-o o h \*(-- NeighbourHood
.PP
\&\fBDocs\fR \*(-- \f(CW\*(C`C\-o C\-d\*(C'\fR \*(-- Show docs (POD/signature/etc) for the symbol
(module/method/sub) at point. A doc hint is displayed in the echo area
(for methods and subs), or a new \s-1POD\s0 buffer is created (for modules).
.PP
\&\fBDocument Inheritance\fR \*(-- \f(CW\*(C`C\-o d i\*(C'\fR \*(-- Show the Inheritance hierarchy
for the current Class in the echo area.
.PP
\&\f(CW\*(C`C\-o d u\*(C'\fR \*(-- Document 'use Module' statements in the echo area.
.PP
\&\fBGo To\fR \*(-- \f(CW\*(C`C\-o C\-g\*(C'\fR \*(-- Open file at proper location for module,
method/sub declaration for the symbol (module/method/sub) at point. If
no sub declaration is available (like for generated getters/setters),
any appropriate \s-1POD\s0 is used instead.
.PP
\&\fBGo To Use\fR \*(-- \f(CW\*(C`C\-o g u\*(C'\fR \*(-- Go to the 'use Module' section of the current buffer.
.PP
\&\fBGo To 'new'\fR \*(-- \f(CW\*(C`C\-o g n\*(C'\fR \*(-- Go to the 'new' method of the current
class.
.PP
\&\fBGo To Base Class\fR \*(-- \f(CW\*(C`C\-o g b\*(C'\fR \*(-- Open the file of the base class
of the current class. This will take you up one level in the
inheritance hierarchy.
.PP
\&\fBGo To Module\fR \*(-- \f(CW\*(C`C\-o g m\*(C'\fR \*(-- Open the source file of the module at
point.
.PP
\&\fBGo To Version Control\fR \*(-- \f(CW\*(C`C\-o g v\*(C'\fR \*(-- Go to the Project view of
the current Version Control system.
.PP
\&\fBGo To Tests \- Other Files\fR \*(-- \f(CW\*(C`C\-o g t o\*(C'\fR \*(-- Go to any related test
or source files given a Devel::CoverX::Covered covered db.
.PP
\&\fBGo To Project's Other Files\fR \*(-- \f(CW\*(C`C\-o g p o\*(C'\fR \*(-- Go to
\&\fIcorresponding\fR files given a \f(CW\*(C`.corresponding_file\*(C'\fR config file (see
File::Corresponding).
.PP
\&\fBFind with Ack\fR \*(-- \f(CW\*(C`C\-o f a\*(C'\fR \*(-- Search for the selected text, or
word at point, or whatever, using Ack.
.PP
\&\fBFind sub declarations\fR \*(-- \f(CW\*(C`C\-o f s\*(C'\fR \*(-- Search for sub declarations
of the method name, or word at point.
.PP
\&\fBFind method calls\fR \*(-- \f(CW\*(C`C\-o f c\*(C'\fR \*(-- Search for method calls of the
method name, or word at point.
.PP
\&\fBGo To Find Buffer\fR \*(-- \f(CW\*(C`C\-o g f\*(C'\fR to go to the \fB*grep*\fR buffer.
.PP
\&\fBRun file\fR \*(-- \f(CW\*(C`C\-o C\-r\*(C'\fR \*(-- Run the current file using the
Compilation mode and the settings appropriate for the source type
(Test, Module, etc.). Highlight errors and jump to source with C\-c
C\-c.
.PP
\&\fBEdit \- Add Use Statement\fR \*(-- \f(CW\*(C`C\-o e a u\*(C'\fR \*(-- Add a 'use Module'
statement to the 'use Module' section at the top. Default Module name
is module at point.
.PP
\&\fBEdit \- Move Use Statement\fR \*(-- \f(CW\*(C`C\-o e m u\*(C'\fR \*(-- Move the 'use Module'
statement at point to the 'use Module' section at the top.
.PP
\&\fBEdit Test Count\fR \*(-- \f(CW\*(C`C\-o e t c\*(C'\fR \*(-- Increase the test count
(e.g. \*(L"tests => 43\*(R")
.PP
\&\fBAssist With Test Count\fR \*(-- \f(CW\*(C`C\-o a t\*(C'\fR \*(-- Synchronize invalid test
count in .t file with the \fB*compilation*\fR buffer.
.PP
Flymake may be used to highlight syntax errors, warnings, and
Perl::Critic violations in the source while editing (continously or at
every save).
.SS "From Vim"
.IX Subsection "From Vim"
There is no integraton with Vim available. Well, not properly
anyway. If you pass the option
.PP
.Vb 1
\& \-\-io_type=editor_vim
.Ve
.PP
to perly_sense, the output will be serialized to Vim Dictionary data
structures <http://vimdoc.sourceforge.net/htmldoc/eval.html#Dictionaries>.
.SS "From other editors"
.IX Subsection "From other editors"
Any editor that is programmable and that can call a shell script could
take advantage of at least some parts of PerlySense to implement
something similar to the Emacs functionality. And most editors are
programmable by the authors, if not by the users.
.SS "From the command line"
.IX Subsection "From the command line"
.IP "\(bu" 4
Create Project
.Sp
.Vb 1
\&  perly_sense create_project [\-\-dir=DIR]
.Ve
.Sp
Create a PerlySense project in \s-1DIR\s0 (default is current dir).
.Sp
If there is already a project.yml file, back it up with a datestamp
first.
.Sp
(Note that you don't need to create a project before start using
PerlySense. Read more below).
.IP "\(bu" 4
Process Project Source Files
.Sp
.Vb 1
\&  perly_sense process_project [\-\-dir=.]
.Ve
.Sp
Cache all modules in the project that \-\-dir belongs to.
.IP "\(bu" 4
Process Source Files in \f(CW@INC\fR
.Sp
.Vb 1
\&  perly_sense process_inc
.Ve
.Sp
Cache all the modules in \f(CW@INC\fR.
.Sp
This is a useful thing to do after installation (and after each
upgrade), but it will take a while so put it in the background and let
it churn away at those modules.
.RS 4
.IP "\(bu" 4
Unix
.Sp
.Vb 1
\&  perly_sense process_inc &        # (well, you knew that already)
.Ve
.IP "\(bu" 4
Windows
.Sp
.Vb 1
\&  start /MIN perly_sense process_inc
.Ve
.RE
.RS 4
.RE
.IP "\(bu" 4
Get Info
.Sp
.Vb 1
\&  perly_sense info
.Ve
.Sp
Display useful information about what the current project directory,
user home directory, etc. is.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
.SS "Module Installation"
.IX Subsection "Module Installation"
Install the Devel::PerlySense module and accompanying elisp by using a
configured \s-1CPAN\s0 shell, like this:
.PP
.Vb 1
\&  cpan Devel::PerlySense
.Ve
.PP
When everything is installed, verify by running
.PP
.Vb 1
\&  perly_sense info
.Ve
.PP
The elisp is installed next to the Perl source (so it works to install
as an unpriviliged user, and you don't \fIhave\fR to have Emacs
installed, and the elisp and Perl source are always in sync).
.SS "Supporting modules"
.IX Subsection "Supporting modules"
These aren't needed to begin with, but may be very useful.
.IP "\(bu" 4
Devel::CoverX::Covered
.Sp
If you have a lot of tests to navigate and run a nightly build with
Devel::Cover to generate test coverage.
.IP "\(bu" 4
File::Corresponding
.Sp
If you have an \s-1MVC\s0 style class structure with the same entity
represented in different directories (e.g. Controller::Aeroplane,
Model::Aeroplane, etc.).
.SS "Emacs installation"
.IX Subsection "Emacs installation"
Make sure the Devel::PerlySense \s-1CPAN\s0 module is installed, it contains
the required elisp files which will be loaded automatically with the
following in your .emacs config file:
.PP
.Vb 1
\&    ;; *** PerlySense Config ***
\&
\&    ;; ** PerlySense **
\&    ;; The PerlySense prefix key (unset only if needed, like for \eC\-o)
\&    (global\-unset\-key "\eC\-o")
\&    (setq ps/key\-prefix "\eC\-o")
\&
\&
\&    ;; ** Flymake **
\&    ;; Load flymake if t
\&    ;; Flymake must be installed.
\&    ;; It is included in Emacs 22
\&    ;;     (or http://flymake.sourceforge.net/, put flymake.el in your load\-path)
\&    (setq ps/load\-flymake t)
\&    ;; Note: more flymake config below, after loading PerlySense
\&
\&
\&    ;; *** PerlySense load (don\*(Aqt touch) ***
\&    (setq ps/external\-dir (shell\-command\-to\-string "perly_sense external_dir"))
\&    (if (string\-match "Devel.PerlySense.external" ps/external\-dir)
\&        (progn
\&          (message
\&           "PerlySense elisp files  at (%s) according to perly_sense, loading..."
\&           ps/external\-dir)
\&          (setq load\-path (cons
\&                           (expand\-file\-name
\&                            (format "%s/%s" ps/external\-dir "emacs")
\&                            ) load\-path))
\&          (load "perly\-sense")
\&          )
\&      (message "Could not identify PerlySense install dir.
\&    Is Devel::PerlySense installed properly?
\&    Does \*(Aqperly_sense external_dir\*(Aq give you a proper directory? (%s)" ps/external\-dir)
\&      )
\&
\&
\&    ;; ** Flymake Config **
\&    ;; If you only want syntax check whenever you save, not continously
\&    (setq flymake\-no\-changes\-timeout 9999)
\&    (setq flymake\-start\-syntax\-check\-on\-newline nil)
\&
\&    ;; ** Code Coverage Visualization **
\&    ;; If you have a Devel::CoverX::Covered database handy and want to
\&    ;; display the sub coverage in the source, set this to t
\&    (setq ps/enable\-test\-coverage\-visualization nil)
\&
\&    ;; ** Color Config **
\&    ;; Emacs named colors: http://www.geocities.com/kensanata/colors.html
\&    ;; The following colors work fine with a white X11
\&    ;; background. They may not look that great on a console with the
\&    ;; default color scheme.
\&    (set\-face\-background \*(Aqflymake\-errline "antique white")
\&    (set\-face\-background \*(Aqflymake\-warnline "lavender")
\&    (set\-face\-background \*(Aqdropdown\-list\-face "lightgrey")
\&    (set\-face\-background \*(Aqdropdown\-list\-selection\-face "grey")
\&
\&
\&    ;; ** Misc Config **
\&
\&    ;; Run calls to perly_sense as a prepared shell command. Experimental
\&    ;; optimization, please try it out.
\&    (setq ps/use\-prepare\-shell\-command t)
\&
\&    ;; *** PerlySense End ***
.Ve
.SS "Emacs Configuration"
.IX Subsection "Emacs Configuration"
The most important config you can change is the prefix key.
.PP
The default, \eC\-o, seemed to have a rater low useful-to-keystroke
ratio and so was a strong candidate for stealing for this much more
important purpose :) Now, the \fIproper\fR way of doing this is of course
to some kind of C\-c prefix. You decide.
.PP
If you want to use flymake to do background syntax and Perl::Critic
checks, set ps/load\-flymake to t (this is a very nifty thing,
so yes you want to do this) and configure the colors to your liking.
.PP
Note: This also needs to be enabled on a per-project basis (see
below).
.PP
Once you have restarted Emacs, you might want to browse around the
customizations by doing
.PP
.Vb 1
\&  M\-x customize\-group perly\-sense
.Ve
.SH "GETTING STARTED WITH EMACS"
.IX Header "GETTING STARTED WITH EMACS"
This is quite a handfull of new features, and you're not likely to be
able to use them efficiently from day one. Remember, Emacs is all
about acquiring finger memory, one feature at a time.
.PP
These are the ones I use every day so they may be a good start:
.IP "\(bu" 4
Go to Module
.IP "\(bu" 4
Go to base class
.IP "\(bu" 4
Document Class Hierarchy
.IP "\(bu" 4
Go to Version Control
.IP "\(bu" 4
Find with Ack
.IP "\(bu" 4
Find sub declerations
.IP "\(bu" 4
Run tests, Re-run tests
.IP "\(bu" 4
Assist with Test count
.SS "Reading Docs"
.IX Subsection "Reading Docs"
\fISmart docs\fR
.IX Subsection "Smart docs"
.PP
\&\f(CW\*(C`C\-o C\-d\*(C'\fR is the \*(L"Smart docs\*(R" command. It brings up \s-1POD\s0 documentation
for what's at point.
.PP
Put the cursor on the \f(CW\*(C`method\*(C'\fR word of a \f(CW\*(C`$self\->method\*(C'\fR call
and press \f(CW\*(C`C\-o C\-d\*(C'\fR and wait until a documentation hint for the
method call is displayed briefly in the echo area. PerlySense will
look in base classes if the method can't be found in the current
class.
.PP
Put the cursor on the \f(CW\*(C`method\*(C'\fR word of an \f(CW$object\fR\->method call
and press \f(CW\*(C`C\-o C\-d\*(C'\fR to see the docs hint. PerlySense will look
through all your \f(CW\*(C`use\*(C'\fRd modules (and their base classes) for the
method call and try to identify the best match.
.PP
Note! The first time each module is parsed this will take a second or
two, and the very first time you run the command with lots of \*(L"use\*(R"
modules it's bound to take a lot longer than that.
.PP
Put the cursor on a module name and press \f(CW\*(C`C\-o C\-d\*(C'\fR to bring up a new
buffer with the \s-1POD\s0 for that module (this is similar to the cperl-mode
feature, only a) not as good, but b) it works on Windows).
.PP
Press \f(CW\*(C`C\-o C\-d\*(C'\fR with nothing under the cursor brings up a \s-1POD\s0 buffer
for the current file.
.PP
\fIDocument Inheritance\fR
.IX Subsection "Document Inheritance"
.PP
\&\f(CW\*(C`C\-o d i\*(C'\fR will briefly display the Inheritance hierarchy for the
current Class in the echo area. Example:
.PP
.Vb 3
\&    [ DBIx::Class::Componentised        ]
\&    [ DBIx::Class                       ] \-\-> [ Class::Data::Accessor ]
\&    [<CatalystX::FeedMe::DBIC::FeedItem>]
.Ve
.PP
\fIDocument Used Modules\fR
.IX Subsection "Document Used Modules"
.PP
\&\f(CW\*(C`C\-o d u\*(C'\fR will briefly display the list of modules used from the
current buffer in the echo area. Example:
.PP
.Vb 3
\&    [ Carp               ] [ File::Spec ] [ Win32::OLE::Const          ]
\&    [ Class::MethodMaker ] [ File::Temp ] [ Win32::Word::Writer::Table ]
\&    [ Data::Dumper       ] [ Win32::OLE ]
.Ve
.SS "Browsing Code"
.IX Subsection "Browsing Code"
\fISmart go to\fR
.IX Subsection "Smart go to"
.PP
\&\f(CW\*(C`C\-o C\-g\*(C'\fR is the \*(L"Smart go to\*(R" command. It's similar to Smart Docs,
but instead of bringing the docs to you, it brings you to the
definition of what's at point.
.PP
The definition can be either the sub declaration, or if the
declaration can't be found (like for auto-generated getters/setters,
autoloaded subs etc), the \s-1POD\s0 documentation for the sub.
.PP
Before you go anywhere the mark is set. Go back to earlier marks
globally with C\-x C\-SPC, or locally with C\-u C\-SPC.
.PP
\fIGo to Module\fR
.IX Subsection "Go to Module"
.PP
\&\f(CW\*(C`C\-o g m\*(C'\fR \*(-- Go to Module at point. Useful if \*(L"Smart go to\*(R" can't
identify exactly what's at point.
.PP
Default is the selected text, or the
Module at point.
.PP
\fIGo to Base Class\fR
.IX Subsection "Go to Base Class"
.PP
\&\f(CW\*(C`C\-o g b\*(C'\fR takes you up one level in the inheritance hierarchy. If the
current class has many base classes, you'll have to choose which one
to go to.
.PP
If the current method is implemented in that base class, go to the sub
definition.
.PP
After going to the Base Class, the Inheritance tree of that class is
displayed in the echo area so you can see where you ended up.
.PP
\fIGo to the 'new' method\fR
.IX Subsection "Go to the 'new' method"
.PP
\&\f(CW\*(C`C\-o g n\*(C'\fR takes you to the definition of the 'new' method of the
current class (in this class, or a parent class). But if you're
unlucky, it might take you to your \s-1OO\s0 helper module's default new.
.PP
\fIGo To 'use Module' section\fR
.IX Subsection "Go To 'use Module' section"
.PP
\&\f(CW\*(C`C\-o g u\*(C'\fR takes you to the line below the last 'use Module' statement
in the the current buffer.
.PP
\fIGo to Version Control\fR
.IX Subsection "Go to Version Control"
.PP
\&\f(CW\*(C`C\-o g v\*(C'\fR \*(-- Go to the Project view for the current Version Control
system. This typically displays the change status of the files in the
project. A dired of the Project dir is used in lieu of a \s-1VCS\s0.
.PP
First, try to go to any existing \s-1VC\s0 project buffer.
.PP
If there is no \s-1VC\s0 buffer open, find out what \s-1VCS\s0 is used, and display
the Project view.
.PP
Supported \s-1VC\s0 systems:
.IP "\(bu" 4
Subversion \*(-- Quick intro to *svn\-status*
.Sp
_ (underscore) \- display only the changed files (toggle)
.Sp
n, p, m, u \*(-- next, previous, mark, unmark
.Sp
E \*(-- diff the changes in the current file
.Sp
c \*(-- commit file(s)
.Sp
r \*(-- revert file(s)
.Sp
X v \*(-- resolve conflict (or X X, I'm not sure what the difference is)
.Sp
etc, etc, etc, do a C\-h m to see all the goodies.
.Sp
See also:
.RS 4
.IP "\(bu" 4
http://www.credmp.org/index.php/2007/12/08/emacs\-hidden\-gems\-version\-control/ <http://www.credmp.org/index.php/2007/12/08/emacs-hidden-gems-version-control/>,
.IP "\(bu" 4
http://www.emacsblog.org/2007/05/17/package\-faves\-psvn/ <http://www.emacsblog.org/2007/05/17/package-faves-psvn/>
.RE
.RS 4
.RE
.IP "\(bu" 4
Git \*(-- Magit
.Sp
This requires you to have Magit installed. Download and manual at:
<http://zagadka.vm.bytemark.co.uk/magit/>.
.Sp
When you switch to an existing Magit status buffer the status is
refreshed automatically to display the current status.
.Sp
If there are many *magit: NAME* buffers open, the first existing one
will be used (whichever that might be).
.PP
\fIGo to Project's Other Files\fR
.IX Subsection "Go to Project's Other Files"
.PP
\&\f(CW\*(C`C\-o g p o\*(C'\fR \*(-- Navigate to \fIother\fR source files in the project that
correspond to the current file.
.PP
This is useful if you have similarly named files in different parts of
the source tree that belong to each other, as is common in projects
with an \s-1MVC\s0 structure (e.g. those based on Catalyst).
.PP
This requires that you have a \f(CW\*(C`.corresponding_file\*(C'\fR config file in
the \f(CW\*(C`.PerlySenseProject\*(C'\fR or project root directory (or your home
directory).
.PP
See File::Corresponding for details.
.SS "Finding Code"
.IX Subsection "Finding Code"
\fIFind with Ack\fR
.IX Subsection "Find with Ack"
.PP
\&\f(CW\*(C`C\-o f a\*(C'\fR \*(-- Ack through the source and display the hits in a
\&\fB*grep*\fR buffer. ack is like grep, but more suitable for
development.
.PP
The search takes place from the Project directory. Before running ack
you'll get to edit the command line with a sensible default chosen from:
.IP "\(bu" 4
the active region
.IP "\(bu" 4
the word at point (with the \f(CW\*(C`\-w\*(C'\fR whole word option)
.PP
When editing the ack command you can use the following keys to set options
.PP
.Vb 8
\& |\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\& | "C\-o w" | toggle | \-w     | Whole word                               |
\& | "C\-o q" | toggle | \-Q     | Quote metacharacters, pattern is literal |
\& | "C\-o i" | toggle | \-i     | Ignore case                              |
\& | "C\-o a" | use    | \-\-all  |                                          |
\& | "C\-o p" | use    | \-\-perl |                                          |
\& | "C\-o s" | use    | \-\-sql  |                                          |
\& |\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
.Ve
.PP
For details, refer to the ack documentation (the program was
installed as a dependency of PerlySense).
.PP
Remember that earlier searches are available in the command history,
just like with grep.
.PP
Tip: You can jump from a source file to the next hit with \f(CW\*(C`C\-c C\-c\*(C'\fR
(type \f(CW\*(C`C\-h m\*(C'\fR in the \fB*grep*\fR buffer to see the mode documentation).
.PP
Tip: if you need to find something else while browsing the \fB*grep*\fR
buffer, you can easily rename the current \fB*grep*\fR buffer to
something else using \f(CW\*(C`M\-x rename\-buffer\*(C'\fR.
.PP
\fIFind sub declarations\fR
.IX Subsection "Find sub declarations"
.PP
\&\f(CW\*(C`C\-o f s\*(C'\fR \*(-- Ack the Project for \fIsub declarations\fR of the method,
or word at point.
.PP
I.e. look for lines with \f(CW\*(C`sub NAME\*(C'\fR.
.PP
The point can be either on the method (\f(CW\*(C`$self\->st|ore\*(C'\fR), or on
the object (\f(CW\*(C`$us|er_agent\->get()\*(C'\fR).
.PP
\fIFind method calls\fR
.IX Subsection "Find method calls"
.PP
\&\f(CW\*(C`C\-o f c\*(C'\fR \*(-- Ack the Project for \fImethod calls\fR to the method, or
word at point.
.PP
I.e. look for lines with \f(CW\*(C`\->NAME\*(C'\fR.
.PP
\fIGo to Find-buffer\fR
.IX Subsection "Go to Find-buffer"
.PP
Invoke \f(CW\*(C`C\-o g f\*(C'\fR to go to the \fB*grep*\fR buffer.
.SS "Class Overview"
.IX Subsection "Class Overview"
Pressing \f(CW\*(C`C\-o C\-o\*(C'\fR will bring up the Class Overview of the Class name
at point (not yet implemented), or otherwise the current Class (the
active Package).
.PP
Example class CatalystX::FeedMe::Controller::Feed
.PP
.Vb 8
\&  * Inheritance *
\&       [ Class::Accessor                     ]
\&    +> [ Class::Accessor::Fast               ] <\-\-\-\-\-+
\&    |  [ Catalyst::AttrContainer             ] \-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    |    |                                           |                           v
\&    +\- [ Catalyst::Base                      ] \-\-> [ Catalyst::Component ] \-\-> [ Class::Data::Inheritable ]
\&       [ Catalyst::Controller                ]
\&       [<CatalystX::FeedMe::Controller::Feed>]
\&
\&  * Uses *
\&  [ Data::Dumper      ] [ XML::Atom::Syndication::Content ] [ XML::Atom::Syndication::Feed ]
\&  [ Template::Filters ] [ XML::Atom::Syndication::Entry   ] [ XML::Atom::Syndication::Link ]
\&
\&  * NeighbourHood *
\&  [ CatalystX::FeedMe::DBIC ] [<CatalystX::FeedMe::Controller::Feed    >] \-none\-
\&                              [ CatalystX::FeedMe::Controller::FeedItem ]
\&                              [ CatalystX::FeedMe::Controller::Homepage ]
\&                              [ CatalystX::FeedMe::Controller::Root     ]
\&
\&  * Bookmarks *
\&  \- Todo
\&  Feed.pm:83: remove duplication
\&
\&  * API *
\&  \e>mutator_name_for
\&  \->new
\&  \->path_prefix
\&  ...
.Ve
.PP
\fIOverview sections\fR
.IX Subsection "Overview sections"
.PP
In addition to the full Overview, each section may be displayed
individually:
.IP "\(bu" 4
C\-o o i \*(-- Inheritance
.IP "\(bu" 4
C\-o o a \*(-- \s-1API\s0
.IP "\(bu" 4
C\-o o b \*(-- Bookmarks
.IP "\(bu" 4
C\-o o u \*(-- Uses
.IP "\(bu" 4
C\-o o h \*(-- NeighbourHood
.PP
The \fBInheritance\fR section shows all Base classes of the
Class. Inheriting from something like Catalyst is hopefully the
hairiest you'll see. Classes inherit from their parents upwards in the
diagram unless there is an arrow pointing elsewhere.
.PP
The \fBUses\fR section shows all used modules in the Class.
.PP
The \fBNeighbourHood\fR section shows three columns (1: parent dir, 2:
current dir, 3: subdir for the current class) with Classes located
nearby (this can be bizarrely huge (and take a long time) if you
browse your site_lib or similar).
.PP
(This was disabled for having a bad time/useful ratio. Use C\-o o h to
bring up only the NeighbourHood).
.PP
The \fBBookmarks\fR section shows matches for bookmark definitions you
have defined in the Project config (see below).
.PP
the \fB\s-1API\s0\fR section shows things that look like methods and properties
of the class (sub declarations, \f(CW$self\fR method calls,
\&\f(CW$self\fR\->{hash_ref_keys}):
.PP
.Vb 2
\&  \->method_in_this_class
\&  \e>method_in_base_class  (note the arrow coming from above)
.Ve
.PP
Private methods (named with a leading _) are displayed as regular
methods. Same goes for private methods in base classes, except when
the base class is outside of your Project (like for \s-1CPAN\s0 modules).
.PP
Why is this?
.PP
If it's your code base you're interested in everything, but if you
inherit from a \s-1CPAN\s0 module, you don't care (you even shouldn't care)
about the implementation of that module.
.PP
Note that you can still see the private methods of those modules by
doing a Class Overview on them, or any of the modules outside your
current Project (thereby changing the current Project to the directory
where those modules are installed).
.PP
\fIKey bindings\fR
.IX Subsection "Key bindings"
.PP
When in the Class Overview buffer:
.PP
g \*(-- Go to the file of the thing at point (Module/Method/Bookmark)
.PP
d \*(-- Documentation for the thing at point (Module/Method)
.PP
c \*(-- Class Overview for the thing at point. \s-1RET\s0 does the same.
.PP
I \*(-- Move point to the Inheritance heading in the buffer.
.PP
U \*(-- Move point to the Uses heading in the buffer.
.PP
H \*(-- Move point to the NeighbourHood heading (mnemonic: 'Hood).
.PP
B \*(-- Move point to the Bookmarks heading.
.PP
A \*(-- Move point to the \s-1API\s0 heading.
.PP
N \*(-- Move point to the '\->new' method in the buffer (if any).
.PP
q \*(-- Quit the Class Overview buffer.
.SS "Testing"
.IX Subsection "Testing"
\fIRun File\fR
.IX Subsection "Run File"
.PP
\&\f(CW\*(C`C\-o C\-r\*(C'\fR \*(-- Run the file of the current buffer using the Compilation
mode.
.PP
Files are run according to the source type, which is determined by the
file name (see the config file). The default for .t files is to run
\&\*(L"prove \-v\*(R", for .pm files \*(L"perl \-c\*(R", etc. This can be configured per
Project (see below).
.PP
Files can also be run using an Alternate Command using \f(CW\*(C`C\-u C\-o C\-r\*(C'\fR
if you have specified one in the config file. This might be useful if
you want to re-generate or restart something before running the file,
but only sometimes. Or, maybe you want to run some tests without the
\&\-v flag or something.
.PP
The file is run from the Project root directory or from the file
directory depending on the file type, and the \f(CW@INC\fR is set
appropriately. You can also specify additional \f(CW@INC\fR directories in the
Project config.
.PP
Note that you can configure whatever type of run profile you like,
not just Perl source files.
.PP
As a taste of what's possible, imagine that you have a test framework
with .yml acceptance test data files and a corresponding yml\-runner.pl
script. You can set up the config so you can type \f(CW\*(C`C\-o C\-r\*(C'\fR while
editing the .yaml file to run that test. And if you need to regenerate
some fixtures or something before running the yml test, you can
configure the Alternate Command to do that (run with \f(CW\*(C`C\-u C\-o
C\-r\*(C'\fR). Refer to the Devel::PerlySense::Cookbook for details.
.PP
If any warnings, errors or test failures are encountered, they are
highlighted in the \fB*compilation*\fR buffer. Press \s-1RET\s0 on a highlighted
line to go to the source. Jump between errors with Tab.
.PP
Use C\-c C\-c to move from one error to the next while editing.
.PP
If you wish to start many runs at the same time, rename the
compilation buffer with \f(CW\*(C`M\-x rename\-buffer\*(C'\fR.
.PP
\fIRe-run File\fR
.IX Subsection "Re-run File"
.PP
Invoke \f(CW\*(C`C\-o C\-r\*(C'\fR from within the \fB*compilation*\fR buffer to re-run
(\f(CW\*(C`M\-x recompile\*(C'\fR) the file. Useful when you have skipped around the
source fixing errors and the .t file isn't visible.
.PP
\&\f(CW\*(C`C\-o r r\*(C'\fR \*(-- If not even the \fB*compilation*\fR buffer is visible,
issue Re-Run File from anywhere to bring it up and re-run.
.PP
Note: this will re-run whatever is displayed in the \fB*compilation*\fR
buffer.
.PP
\fIGo to Run-buffer\fR
.IX Subsection "Go to Run-buffer"
.PP
Invoke \f(CW\*(C`C\-o g r\*(C'\fR to go to the \fB*compilation*\fR buffer.
.PP
\fIEdit Test Count\fR
.IX Subsection "Edit Test Count"
.PP
\&\f(CW\*(C`C\-o e t c\*(C'\fR \*(-- Increase the test count number in the line resembling
.PP
.Vb 1
\&  use Test::More tests => 43;
.Ve
.PP
without moving point. The current and new test count is reported in
the echo area.
.PP
Increase with the numeric argument (e.g. \f(CW\*(C`C\-u \-2 C\-o e t c\*(C'\fR), or
default 1.
.PP
\fIAssist With Test Count\fR
.IX Subsection "Assist With Test Count"
.PP
\&\f(CW\*(C`C\-o a t\*(C'\fR \*(-- If the test count in a .t file is out of sync with
what's correctly reported when running the test in the
\&\fB*compilation*\fR buffer (see Run File), use this command to update the
\&.t file.
.PP
This updates the
.PP
.Vb 1
\&  use Test::More tests => 43;
.Ve
.PP
line in the current buffer, so be sure to only run this when the
\&\fB*compilation*\fR buffer contains the run result of this buffer.
.PP
\fIRun Single Test::Class Method\fR
.IX Subsection "Run Single Test::Class Method"
.PP
If you use Test::Class to write your tests, you may sometimes want
to run just a single test method.
.PP
Hit \f(CW\*(C`C\-o r m\*(C'\fR to mark the current sub as the current test method, and
\&\f(CW\*(C`C\-o r m\*(C'\fR again to unmark it. This will set the \f(CW$TEST_METHOD\fR
environment variable during program runs, so when you run this test
class, only the marked method will be run.
.PP
The current test method is indicated with a \*(L"Test::Class \-\->\*(R" next to
it.
.PP
\fIGo to Tests \- Other Files\fR
.IX Subsection "Go to Tests - Other Files"
.PP
\&\f(CW\*(C`C\-o g t o\*(C'\fR \*(-- In a test file, navigate to the source files that are
covered by that test file.
.PP
In a source file, navigate to test files covering the file. If the
point is on a line with a sub declaration, the list of test files is
limited to those that cover that particular sub.
.PP
This requires that Devel::CoverX::Covered is installed and a
Devel::Cover cover_db in the project root directory.
.PP
See Devel::CoverX::Covered for details.
.PP
\fIGo to Error line\fR
.IX Subsection "Go to Error line"
.PP
If you run tests in a regular shell (inside Emacs or in a terminal
window), this may be handy.
.PP
\&\f(CW\*(C`C\-o g e\*(C'\fR \*(-- If point is located on an error line from a syntax
error, or a stack trace from the debugger or similar, go to that
file+line.
.PP
If no file name can be found, prompt for a piece of text that contains
the file+line spec. The kill ring or clipboard text is used as default
if available (so it's easy to just copy the error line from the
terminal, run this command and hit return to accept the default text).
.SS "Debugging Code"
.IX Subsection "Debugging Code"
\fIRun File in Debugger\fR
.IX Subsection "Run File in Debugger"
.PP
\&\f(CW\*(C`C\-o r d\*(C'\fR \*(-- Run the file of the current buffer using the Emacs
integrated Perl debugger. This the same as the excellent \f(CW\*(C`M\-x
perldb\*(C'\fR, except a few annoyances are fixed, like the include
directories, the working directory, the default command line etc.
.PP
Note that if you have spaces in your file names, this might not work
(it's a perldb thing).
.PP
The debugger is started according to the file source type, which is
determined by the file name (see the config file).
.PP
You can also use \f(CW\*(C`C\-u C\-o r d\*(C'\fR to Debug with an Alternate Command,
just like with Run File.
.PP
This can all be configured similar to how files are run (see above).
.PP
Most files are run from the Project root directory by default.
.PP
\fICommands and key bindings\fR
.IX Subsection "Commands and key bindings"
.PP
Commonly used commands:
.PP
.Vb 10
\&    |\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&    | Source      | DB   | Command                 |
\&    |\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&    | C\-x C\-a C\-n | n    | Next line (step over)   |
\&    | C\-x C\-a C\-s | s    | Step into               |
\&    |             | RET  | Repeat last n or s      |
\&    | C\-x C\-a C\-r | r    | Return from sub         |
\&    | C\-x C\-a C\-u |      | Run to (Until) point    |
\&    |             | x $v | Dump variable $v        |
\&    |             | T    | Stack trace             |
\&    |             | y    | Dump lexicals (mY vars) |
\&    |             | R    | Restart                 |
\&    |             | m $o | List methods of $o      |
\&    |\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
.Ve
.PP
\fIDumping objects\fR
.IX Subsection "Dumping objects"
.PP
.Vb 1
\&  x $VAR
.Ve
.PP
to print/dump objects.
.PP
See <http://use.perl.org/~jplindstrom/journal/34427> for how to deal
with large objects (put the \f(CW\*(C`.perldb\*(C'\fR file in \f(CW$HOME\fR or the project
root dir).
.PP
\fIBreakpoints\fR
.IX Subsection "Breakpoints"
.PP
Create a programmatic breakpoint like this
.PP
.Vb 1
\&  $DB::single = 1;
.Ve
.PP
\fIMore Documentation\fR
.IX Subsection "More Documentation"
.PP
Once the debugger is started, refer to the Gud menu for a few useful
commands and key bindings (gud = Grand Unified Debugger). See also:
<http://www.gnu.org/software/emacs/manual/html_node/emacs/Debuggers.html>
.PP
Since the Perl debugger command line is available, make sure you read
up on that too: <http://perldoc.perl.org/perldebug.html> (especially
the <<, {{, etc. are more useful than they might seem at
first).
.SS "Displaying Code"
.IX Subsection "Displaying Code"
\fIFlymake Introduction\fR
.IX Subsection "Flymake Introduction"
.PP
\&\*(L"Flymake performs on-the-fly syntax checks of the files being edited
using the external syntax check tool (usually the compiler).
Highlights erroneous lines and displays associated error messages.\*(R"
.PP
Flymake is included in Emacs 22 (or available from
http://flymake.sourceforge.net/, put flymake.el somewhere in your
load-path. [[[explain how to fix brokenness?]]] ).
.PP
PerlySense uses flymake to check syntax, Perl Critic, etc.
.PP
Having Perl::Critic enabled will also speed up other operations by
caching information.
.PP
Three inconveniences with vanilla Flymake are fixed:
.IP "\(bu" 4
no proper \f(CW@INC\fR
.IP "\(bu" 4
only .pl files
.IP "\(bu" 4
\&\*(L"perl \-c\*(R" warns about redefined subs for
recursively used modules (which is perfectly fine Perl)
.PP
Syntax errors and warnings both use the error face.
.PP
Perl::Critic violations use the warning face.
.PP
\fIEnabling Flymake\fR
.IX Subsection "Enabling Flymake"
.PP
First off, flymake itself needs to be enabled. Refer to the Emacs
Installation description above.
.PP
This will enable Flymake for all cperl-mode buffers, causing Emacs to
call perly_sense for each check.
.PP
\&\fIPerlySense won't do anything at this point though\fR. You still need
to configure what should happen during a flymake.
.PP
Create a PerlySense Project directory (see below) and look in the
project.yml file for instructions on how to configure Flymake
activities.
.PP
Set \*(L"syntax\*(R" and/or \*(L"critic\*(R" to 1 to enable them.
.PP
\&\fBThe primary reason \*(L"syntax\*(R" is turned off by default is that it's a
potential security hole\fR; running \*(L"perl \-c\*(R" on a file will not only
check the syntax; \s-1BEGIN\s0 and \s-1CHECK\s0 blocks are also executed. Doing that
on random code may be considered... baaad.
.PP
This way you can have Flymake enabled globally and still not run \*(L"perl
\&\-c\*(R" on everything that happens to be in a buffer.
.PP
\fIUsing Flymake\fR
.IX Subsection "Using Flymake"
.PP
In the Project config file there are some hints on how to customize
Flymake, when it should run, etc. You can also customize it with \f(CW\*(C`M\-x
customize\-group flymake\*(C'\fR.
.PP
(Personally I find the nagging while I type very distracting, but I
welcome the immediate feedback whenever I save the file. \s-1YMMV\s0.)
.PP
Look in the mode line for hints on whether there are any errors or
warnings.
.PP
\&\f(CW\*(C`C\-o s n\*(C'\fR \*(-- Go to the next Source error/warning.
.PP
Display the error in the minibuffer. If the warning is from a
Perl::Critic module, copy the module name into the kill-ring, so you
easily can yank it into the .perlcritic config file to disable
it. (not implemented)
.PP
\&\f(CW\*(C`C\-o s p\*(C'\fR \*(-- Go to the previous Source error/warning.
.PP
\&\f(CW\*(C`C\-o s s\*(C'\fR \*(-- Display the error/warning text of the current line in a
popup. Or display the error in the minibuffer if the display isn't
graphical, or if the ps/flymake\-prefer\-errors\-in\-minibuffer variable
is customized to a true value.
.PP
\fICode Coverage Visualization Introduction\fR
.IX Subsection "Code Coverage Visualization Introduction"
.PP
If you have a test suite, you might like this. You should have tests.
.PP
If you run Devel::Cover, you'll be happy. You should know your code
coverage.
.PP
PerlySense can display the code coverage in the source buffer.
.PP
Currently supported is subroutine coverage, i.e. whether a sub is
covered by tests or not.
.PP
Covered subs are displayed with a discreet green underline, uncovered
subs get a red underline.
.PP
\fICoverage Visualization Setup\fR
.IX Subsection "Coverage Visualization Setup"
.PP
PerlySense uses Devel::CoverX::Covered to manage the coverage
data. Refer to that documentation for how to run your test suite with
Devel::Cover and generate a \*(L"covered\*(R" database.
.PP
The \*(L"covered\*(R" database should reside in your project root dir and
contain files with file names relative to the project root dir (that's
ordinarily the case).
.PP
Note: Running the test suite with Devel::Cover can be very, very
slow. A nightly build is usually a good idea.
.PP
\fIUsing Coverage Visualization\fR
.IX Subsection "Using Coverage Visualization"
.PP
You can toggle Visualization with \f(CW\*(C`C\-o C\-v\*(C'\fR at any time when editing.
.PP
You can also enable Visualization by default in the install script
(see above), or via \f(CW\*(C`M\-x customize\-variable
ps/enable\-test\-coverage\-visualization\*(C'\fR.
.PP
Whenever Visualization is enabled, PerlySense will try to fetch
coverage information just after a file is opened and highlight the
word \*(L"sub\*(R" for each subroutine in the buffer.
.IP "\(bu" 4
A green underline means that the sub was entered at least
once. This does not mean all lines in the sub was covered.
.IP "\(bu" 4
A red underline means the sub wasn't covered at all. Time to write
more tests!
.IP "\(bu" 4
No underline means that the sub isn't in the coverage
database. Maybe the sub was added after the test run, maybe
Devel::Cover didn't manage to capture any coverage information for the
sub.
.Sp
If you really think the sub should be covered, generate a \s-1HTML\s0 report
with Devel::Cover and investigate further.
.PP
The point of the visualization is to provide an ambient feeling of
what's covered or not. Too much detail and color all over the place
and the source turns into a christmas tree! But if you browse past a
complex method and see that it isn't tested, that should ring a bell.
.PP
To increase this effect you may want to only highlight subs with bad
coverage (customize the variable
\&\f(CW\*(C`ps/only\-highlight\-bad\-sub\-coverage\*(C'\fR)
.PP
Note that you can hit \f(CW\*(C`C\-o g t o\*(C'\fR \*(-- \*(L"Go To Tests \- Other Files\*(R" to
see what test files are covering \fIthis file\fR. If you run the command
with the cursor on a \*(L"sub\*(R" line, you'll get only the tests that cover
\&\fIthat particular subroutine\fR.
.SS "Editing Code"
.IX Subsection "Editing Code"
\fIEdit Add 'use Module' Statement\fR
.IX Subsection "Edit Add 'use Module' Statement"
.PP
\&\f(CW\*(C`C\-o e a u\*(C'\fR \*(-- Set mark and add a 'use My::Module;' statement to the
end of the 'use Module' section at the top of the file.
.PP
The default module is the selected text, or the module at point (point
may be on a method call of the module).
.PP
This is typically useful when you realize you're using a module
already, but without a use-statement. But you don't want to leave
where you are just to fiddle with adding it.
.PP
So hit \f(CW\*(C`C\-o e a u\*(C'\fR to add it, see that it got added at a good place
and hit C\-u C\-SPC to return to where you were, and continue doing what
you where doing.
.PP
\fIEdit Move 'use Module' Statement\fR
.IX Subsection "Edit Move 'use Module' Statement"
.PP
\&\f(CW\*(C`C\-o e m u\*(C'\fR \*(-- If point is on a line with a single 'use Module'
statement, set mark and move that statement to the end of the 'use
Module' section at the top of the file.
.PP
This is typically useful for when you encounter a stray 'use Module'
in the middle of the file.
.PP
So type the 'use Module' statement, hit \f(CW\*(C`C\-o e m u\*(C'\fR to move it, see
that it got moved to a good place and hit C\-u C\-SPC to return to where
you were, and continue doing what you where doing.
.PP
\fIAssist With \*(-- Regex\fR
.IX Subsection "Assist With  Regex"
.PP
Hit \f(CW\*(C`C\-o a r\*(C'\fR to bring up the Regex Tool which will let you compose a
Perl regular expression interactively with matching text highlighed.
.PP
The Regex Tool appears in a new frame with three buffers: \fB*Regex*\fR,
\&\fB*Text*\fR and \fB*Groups*\fR.
.PP
If point is on a regular expression in the source code, that regex
will be used to pre-populate the \fB*Regex*\fR buffer. (Not yet
implemented)
.PP
If there is a comment block just above the regex, it will be used to
pre-populate the \fB*Text*\fR buffer. Note that it is very handy to
document the regex with some sample input, so this is a good idea in
general. (Not yet implemented)
.PP
The contents of the \fB*Regex*\fR buffer should look e.g. like this:
.PP
.Vb 1
\&  / part \es (\ew+) \es no:(\ed) /xgm
.Ve
.IP "\(bu" 4
You can use all the usual delimiters, such as / | {} () ", etc.
.IP "\(bu" 4
You can put Perl comments below the regex to temporarily store chunks
of regex code during prototyping.
.IP "\(bu" 4
The modifiers work as expected, including /x and /g .
.PP
The results in the \fB*Groups*\fR buffer are updated as you type in
either the \fB*Regex*\fR or \fB*Text*\fR buffer.
.PP
Use C\-c C\-c to force an update.
.PP
Use C\-c C\-k to quit all the regex-tool buffers and remove the frame.
.SH "THE PERLYSENSE USER DIRECTORY"
.IX Header "THE PERLYSENSE USER DIRECTORY"
PerlySense keeps a per-user directory to store cache files, logs,
etc. The \f(CW\*(C`.PerlySense\*(C'\fR user directory is located under the first
available of these environment variables:
.PP
.Vb 6
\&  $APPDATA
\&  $ALLUSERSPROFILE
\&  $USERPROFILE
\&  $HOME
\&  $TEMP
\&  $TMP
.Ve
.PP
Run
.PP
.Vb 1
\&  perly_sense info
.Ve
.PP
to see which directory is actually being used.
.SH "PROJECTS"
.IX Header "PROJECTS"
PerlySense has the concept of a Project root directory.
.PP
Basically, this is where all the source lives, and where your program
can go to find modules that are used. This is from where tests are run
and files are found.
.PP
You can specify the Project root dir explicitly for your
applications. But if you don't, PerlySense will try and figure out
what the Project root directory is from the context of the surrounding
code.
.PP
This means you can browse source code anywhere on your hard drive
(e.g. \f(CW@INC\fR) without any special setup or configuration. Most things
will just work, without any hassle.
.PP
If you follow the standard directory structure for \s-1CPAN\s0 modules, the
Project directory is typically the one which contains the Makefile.PL,
the lib, bin, and t directory, etc.
.SS "Identifying a Project root directory"
.IX Subsection "Identifying a Project root directory"
The fastest and most solid way for PerlySense to know which is the
Project directory is to create a \f(CW\*(C`.PerlySenseProject\*(C'\fR directory with
a config file in it. This is highly recommended for all of your own
projects.
.PP
The complete project identification strategy is as follows:
.IP "\(bu" 4
First, if there is any directory upwards in the dirctory path with a
\&\f(CW\*(C`.PerlySenseProject\*(C'\fR dir in it, that is the Project directory.
.IP "\(bu" 4
Second, PerlySense will try figure out from where the current file (if
any) was being required/used given the contained package names or used
modules.
.IP "\(bu" 4
Third, if that doesn't work, PerlySense will look for \f(CW\*(C`lib\*(C'\fR and \f(CW\*(C`t\*(C'\fR
directories.
.PP
If that doesn't work, PerlySense is lost and you really do need to
create an explicit Project directory by running the following command
in your intended Project root directory (that would typically be the
directory which has a \f(CW\*(C`lib\*(C'\fR directory in it):
.PP
.Vb 1
\&  perly_sense create_project
.Ve
.PP
Any existing \f(CW\*(C`.PerlySenseProject/project.yml\*(C'\fR config file will be
renamed.
.PP
Note that this all means that the current Project depends on which
file you are looking at. If it's a file within the directory tree
under a \f(CW\*(C`.PerlySenseProject\*(C'\fR directory, that's what the current
Project is. But if you from that file do a Class Overview on an
installed \s-1CPAN\s0 module, the current Project is deduced from that .pm
file, typically making the current Project be the \f(CW\*(C`lib\*(C'\fR or
\&\f(CW\*(C`site_lib\*(C'\fR of your local \s-1CPAN\s0 installation.
.SS "Project Configuration"
.IX Subsection "Project Configuration"
The Project has a .PerlySenseProject/project.yml config file. Here you
can change the name of the Project, add extra \f(CW@INC\fR directories, etc.
.PP
There is a yaml-mode for Emacs, but I haven't got it to work properly
(unless an infinite loop counts as \*(L"properly\*(R" these days). The
shell-script-mode is good enough.
.PP
The config file documentation is where it belongs, in the config file,
so just take a look at it.
.SS "perly_sense Project commands"
.IX Subsection "perly_sense Project commands"
.Vb 1
\&  perly_sense create_project [\-\-dir=DIR]
.Ve
.PP
Create a PerlySense project in \s-1DIR\s0 (default is current dir).
.PP
.Vb 1
\&  perly_sense process_project
.Ve
.PP
Cache all modules in the project. (not implemented)
.SH "BOOKMARKS"
.IX Header "BOOKMARKS"
Bookmarks are regexes that may match against a single line. Each
bookmark definition has a name/moniker under which the matches are
grouped in the Class Overview display.
.PP
The primary point of Bookmarks is to highlight unusual things in the
source. The secondary to make it easy for you go navigate to them.
.PP
This can be anything you like, but things that come to mind are:
.IP "\(bu" 4
\&\s-1TODO\s0 comments
.IP "\(bu" 4
\&\s-1FIXME/XXX/HACK\s0 comments
.IP "\(bu" 4
Things you don't want left in the code, like
.Sp
Breakpoints ($DB::single = 1)
.Sp
Debugging warn/print statements
.SS "Configuration"
.IX Subsection "Configuration"
Bookmarks are defined in the Project Config file (technical details
are documented there).
.SH "KEY BINDING CONVENTIONS"
.IX Header "KEY BINDING CONVENTIONS"
There is a system behind the chosen key bindings in
PerlySense. Knowing the conventions will make it easier to remember
everything.
.SS "Convention: Action based"
.IX Subsection "Convention: Action based"
The first level after the prefix key (\f(CW\*(C`C\-o\*(C'\fR by default) is always an
Action, e.g. Run, or Document.
.PP
(In the case of \f(CW\*(C`C\-o C\-d\*(C'\fR for Document you can either think of it as
\&\*(L"Document this for me!\*(R"  or \*(L"Give me Documentation!\*(R".)
.PP
With a verb at the first level rather than a noun, the Action can be
context sensitive, \*(L"smart\*(R", or DWIMy.
.IP "Smart Goto goes to whatever is under the cursor, be it a module name, a method call, a file name, or an error message." 4
.IX Item "Smart Goto goes to whatever is under the cursor, be it a module name, a method call, a file name, or an error message."
.PD 0
.ie n .IP "Run runs the file differently depending on what kind of file is open (tests are ""proved"", modules are syntax checked, scripts are run, etc)." 4
.el .IP "Run runs the file differently depending on what kind of file is open (tests are ``proved'', modules are syntax checked, scripts are run, etc)." 4
.IX Item "Run runs the file differently depending on what kind of file is open (tests are proved, modules are syntax checked, scripts are run, etc)."
.PD
.SS "Convention: The Action as a Gateway"
.IX Subsection "Convention: The Action as a Gateway"
The first level indicates the Action to perform, and has the Ctrl
modifier as a \*(L"Smart\*(R" / DWIMy modifier. This is both so it's easy to
type \f(CW\*(C`C\-o C\-r\*(C'\fR without releasing the Ctrl key, and to provide a
gateway to more specific actions when typing the key without Ctrl.
.PP
E.g. \f(CW\*(C`C\-o C\-r\*(C'\fR means \*(L"Run file\*(R", \f(CW\*(C`C\-o r r\*(C'\fR means \*(L"Run \- Re-run\*(R".
.PP
E.g. \f(CW\*(C`C\-o C\-g\*(C'\fR means \*(L"Smart Goto\*(R", \f(CW\*(C`C\-o g b\*(C'\fR means \*(L"Goto \- Base
Class\*(R", C\-o g s means \*(L"Goto \- \s-1SUPER\s0 Method\*(R".
.SS "The Main Actions Areas"
.IX Subsection "The Main Actions Areas"
(some of the main areas have no implementations yet)
.IP "\(bu" 4
r \*(-- Run
.Sp
Run files in various ways.
.IP "\(bu" 4
g \*(-- Go to
.Sp
Navigate to various locations in the source.
.IP "\(bu" 4
d \*(-- Document
.Sp
Bring up documentation.
.IP "\(bu" 4
f \*(-- Find
.Sp
Find/search and display things in the source.
.IP "\(bu" 4
o \*(-- Overview
.Sp
Bring up an overview of things.
.IP "\(bu" 4
m \*(-- forMat
.Sp
Reformat source.
.IP "\(bu" 4
e \*(-- Edit
.Sp
Perform smaller convenience editing task.
.IP "\(bu" 4
E \*(-- rEfactor
.Sp
Perform restructuring edits that don't impact functionality/behaviour.
.IP "\(bu" 4
A \*(-- Assist
.Sp
Solve very context sensitive problems.
.SS "Explore Emacs key bindings"
.IX Subsection "Explore Emacs key bindings"
Remember that you can use the usual Emacs feature to display possible
key stroke completions by hitting C\-h whenever in the key stroke
sequence.
.PP
E.g. Hitting \f(CW\*(C`C\-o g C\-h\*(C'\fR will list all available key strokes starting
wiht \f(CW\*(C`C\-o g\*(C'\fR.
.SS "Changing key bindings"
.IX Subsection "Changing key bindings"
Some key bindings may change over time as I figure out what works and
what doesn't. Some key bindings may be reorganized to make more sense
or to just work better.
.SH "IN CLOSING \*(-- ON PARSING PERL"
.IX Header "IN CLOSING  ON PARSING PERL"
Since Perl is so dynamic, a perfect static analysis of the source is
impossible. But not unusably so. Well, hopefully. Most of the time.
.PP
Because of this PerlySense is not about exact rules, but about
heuristics and a 90% solution that isn't perfect, but good-enough.
.PP
PerlySense tries to take advantage of the fact that Perl code is more
than the plain source file. The source lives in a context of \s-1POD\s0 and a
directory structure and common Perl idioms.
.PP
Sometimes when PerlySense can't make a decision, you're expected to
chip in and tell it what you meant.
.PP
Sometimes it won't work at all.
.PP
Such is the way of dynamic languages.
.PP
If it works for you, brilliant, use it to be more productive. If
not...  well, there's always Java >:)
.SS "Syntax Parsing Modules"
.IX Subsection "Syntax Parsing Modules"
PerlySense provides a plugin architecture for supporting custom syntax
provided by \s-1OO\s0 modules such as Moose, or Class::Accessor.
.PP
Currently Moose is supported via the
Devel::PerlySense::Plugin::Syntax::Moose module.
.SH "MORE DOCUMENTATION"
.IX Header "MORE DOCUMENTATION"
Devel::PerlySense::Cookbook
.SH "SEE ALSO"
.IX Header "SEE ALSO"
sepia \- similar effort
.PP
\&\s-1PPI\s0 \- excellent for parsing Perl
.PP
\&\s-1CPANXR\s0 \- also uses \s-1PPI\s0 for cross referencing the \s-1CPAN\s0
.PP
<http://www.DarSerMan.com/Perl/Oasis/> \- Win32 class
browser/IDE. Earlier (a lot) work by me.
.PP
<http://www.perl.com/lpt/a/955> \- Article \*(L"Perl Needs Better Tools\*(R"
.PP
<http://media.pragprog.com/articles/mar_02_archeology.pdf> \- Article \*(L"Software Archeology\*(R"
.PP
http://www.newartisans.com/downloads_files/regex\-tool.el <http://www.newartisans.com/downloads_files/regex-tool.el> \- Regex Tool
.PP
<http://vimdoc.sourceforge.net/htmldoc/eval.html#Dictionaries> \- Vim native data structure
.SH "AUTHOR"
.IX Header "AUTHOR"
Johan Lindstro\*:m, \f(CW\*(C`<johanl buzzwordninja.com>\*(C'\fR
.SH "CONTRIBUTIONS, BUGS, AND CAVEATS"
.IX Header "CONTRIBUTIONS, BUGS, AND CAVEATS"
.SS "\s-1CONTRIBUTIONS\s0"
.IX Subsection "CONTRIBUTIONS"
If you want to hack on PerlySense, fork the project at GitHub:
https://github.com/jplindstrom/p5\-Devel\-PerlySense <https://github.com/jplindstrom/p5-Devel-PerlySense>
.SS "\s-1BUG\s0 \s-1REPORTS\s0"
.IX Subsection "BUG REPORTS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-devel\-perlysense@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel\-PerlySense <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel-PerlySense>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
Tab/space isn't supported by \s-1PPI\s0 yet, but it's supposed to be. So
using Tab instead of spaces won't work properly.
.SS "\s-1KNOWN\s0 \s-1BUGS\s0"
.IX Subsection "KNOWN BUGS"
\&\s-1PPI\s0 is kinda slow for large documents. Lots of objects being created etc.
.PP
There are certainly edge cases. Bug reports with failing tests
appreciated :)
.PP
There is one known infinite loop.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Peter Liljenberg and Phil Jackson for their elisp fu.
.PP
Jonathan Rockway for cool ideas:
<http://blog.jrock.us/articles/Increment%20test%20counter.pod>
.PP
John Wiegley for the regex-tool http://www.newartisans.com/downloads_files/regex\-tool.el <http://www.newartisans.com/downloads_files/regex-tool.el>
.PP
Jaeyoun Chung for dropdown-list http://www.emacswiki.org/cgi\-bin/wiki/dropdown\-list.el <http://www.emacswiki.org/cgi-bin/wiki/dropdown-list.el>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007 Johan Lindstro\*:m, All Rights Reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "*** THE FOLLOWING IS DEVELOPER DOCUMENTATION ***"
.IX Header "*** THE FOLLOWING IS DEVELOPER DOCUMENTATION ***"
.SH "PROPERTIES"
.IX Header "PROPERTIES"
.SS "oCache"
.IX Subsection "oCache"
Cache::Cache object, or undef if no cache is active.
.PP
Default: undef
.SS "oProject"
.IX Subsection "oProject"
Devel::PerlySense::Project object.
.PP
Default: A Devel::PerlySense::Project::Unknown object.
.SS "oHome"
.IX Subsection "oHome"
Devel::PerlySense::Home object.
.PP
Default: A newly created Home object.
.SS "rhConfig"
.IX Subsection "rhConfig"
Hash ref with the current config.
.PP
If there is a known Project, it reflects the Project's config,
otherwise it's the default config.
.PP
Readonly. Note that the _entire_ data structure is readonly. Each time
you change/add/remove a value from it, a kitten is slain. So, dude,
just don't go there!
.SS "\s-1VERSION\s0"
.IX Subsection "VERSION"
The \f(CW$VERSION\fR of this module.
.SS "oBookmarkConfig"
.IX Subsection "oBookmarkConfig"
Devel::PerlySense::BookmarkConfig object.
.SS "rhFileDocumentCache"
.IX Subsection "rhFileDocumentCache"
Hash ref with (keys: absolute file names; keys: Document objects).
.SH "API METHODS"
.IX Header "API METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Create new PerlySense object.
.ie n .SS "setFindProject([file => $file], [dir => $dir])"
.el .SS "setFindProject([file => \f(CW$file\fP], [dir => \f(CW$dir\fP])"
.IX Subsection "setFindProject([file => $file], [dir => $dir])"
Identify a project given the \f(CW$file\fR or \f(CW$dir\fR, and set the oProject
property.
.PP
If there is already a project defined, don't change it.
.PP
If no project was found, don't change oProject.
.PP
Return 1 if there is a valid project, else 0.
.PP
Die on errors.
.SS "oDocumentParseFile($file)"
.IX Subsection "oDocumentParseFile($file)"
Parse \f(CW$file\fR into a new PerlySense::Document object.
.PP
Return the new object.
.PP
If \f(CW$file\fR was already parsed by this PerlySense object, cache that
instance of the Document and return that instead of parsing it again.
.PP
Die on errors (like if the file wasn't found).
.SS "\fIclearInMemoryDocumentCache()\fP"
.IX Subsection "clearInMemoryDocumentCache()"
Clear the rhFileDocumentCache property.
.PP
Return 1.
.ie n .SS "podFromFile(file => $file)"
.el .SS "podFromFile(file => \f(CW$file\fP)"
.IX Subsection "podFromFile(file => $file)"
Return the pod in \f(CW$file\fR as text, or die on errors.
.PP
Die if \f(CW$file\fR doesn't exist.
.ie n .SS "oLocationSmartGoTo(file => $fileOrigin, row => $row, col => $row)"
.el .SS "oLocationSmartGoTo(file => \f(CW$fileOrigin\fP, row => \f(CW$row\fP, col => \f(CW$row\fP)"
.IX Subsection "oLocationSmartGoTo(file => $fileOrigin, row => $row, col => $row)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and determine what is
there. Depending on what's there, find the source
declaration/whatever, find it and return an
Devel::PerlySense::Document::Location object.
.PP
Currently supported:
.PP
.Vb 2
\&  $self\->method, look in current file and base classes. If no sub can
\&  be found, look for POD.
\&
\&  $object\->method, look in current file and used modules. If no sub
\&  can be found, look for POD.
\&
\&  Module::Name (bareword)
\&
\&  Module::Name (as the only contents of a string literal)
.Ve
.PP
If there's nothing at \f(CW$row\fR/col, or if the source can't be found,
return undef.
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "oLocationSmartDoc(file => $fileOrigin, row => $row, col => $row)"
.el .SS "oLocationSmartDoc(file => \f(CW$fileOrigin\fP, row => \f(CW$row\fP, col => \f(CW$row\fP)"
.IX Subsection "oLocationSmartDoc(file => $fileOrigin, row => $row, col => $row)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and determine what is
there. Depending on what's there, find the documentation for it and
return a Document::Location object with the following rhProperty keys set:
.PP
.Vb 4
\&  text \- the docs text
\&  found \- "method" | "module"
\&  docType \- "hint" | "document"
\&  name \- the name of the thing found
.Ve
.PP
Currently supported:
.PP
.Vb 1
\&  Same as for oLocationSmartGoTo
.Ve
.PP
If there's nothing at \f(CW$row\fR/col, use the current document.
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "oLocationMethodDocFromDocument($oDocument, $method)"
.el .SS "oLocationMethodDocFromDocument($oDocument, \f(CW$method\fP)"
.IX Subsection "oLocationMethodDocFromDocument($oDocument, $method)"
Look in \f(CW$oDocument\fR and find the documentation for it and
return a Document::Location object with the following rhProperty keys set:
.PP
.Vb 4
\&  text \- the docs text
\&  found \- "method" | "module"
\&  docType \- "hint" | "document"
\&  name \- the name of the thing found
.Ve
.PP
If possible, also set \*(L"pod\*(R" and \*(L"podHeading\*(R".
.PP
Return undef if no doc could be found.
.PP
Currently, only \s-1POD\s0 is regarded as documentation. Todo: fail to
listing an example/abstracted invocation of the method.
.PP
Die on errors.
.ie n .SS "oLocationMethodDefinitionFromDocument(oDocument => $oDocument, nameClass => $nameClass, nameMethod => $method)"
.el .SS "oLocationMethodDefinitionFromDocument(oDocument => \f(CW$oDocument\fP, nameClass => \f(CW$nameClass\fP, nameMethod => \f(CW$method\fP)"
.IX Subsection "oLocationMethodDefinitionFromDocument(oDocument => $oDocument, nameClass => $nameClass, nameMethod => $method)"
Look in \f(CW$oDocument\fR and find the declaration for \f(CW$nameMmethod\fR and
return a Document::Location object.
.PP
Return undef if no declaration could be found.
.PP
Die on errors.
.ie n .SS "rhRegexExample(file => $fileOrigin, row => $row, col => $row)"
.el .SS "rhRegexExample(file => \f(CW$fileOrigin\fP, row => \f(CW$row\fP, col => \f(CW$row\fP)"
.IX Subsection "rhRegexExample(file => $fileOrigin, row => $row, col => $row)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and find the regex located there,
and possibly the example comment preceeding it.
.PP
Return hash ref with (keys: regex, example; values: source
string). The source string is an empty string if nothing found.
.PP
If there is an example string in a comment, return the example without
the comment #
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "raFileTestOther(file => $fileSource, [sub => $sub])"
.el .SS "raFileTestOther(file => \f(CW$fileSource\fP, [sub => \f(CW$sub\fP])"
.IX Subsection "raFileTestOther(file => $fileSource, [sub => $sub])"
Return array ref with file names of files related to \f(CW$file\fR and
possibly \f(CW$sub\fR, i.e. the \*(L"other\*(R" files related to \f(CW$file\fR.
.PP
If \f(CW$file\fR is a source file, return test files, and vice verca.
.PP
\&\f(CW$sub\fR is only ever active when \f(CW$fileSource\fR is a source file.
.PP
Die if Devel::CoverX::Covered isn't installed.
.ie n .SS "raFileProjectOther(file => $fileSource)"
.el .SS "raFileProjectOther(file => \f(CW$fileSource\fP)"
.IX Subsection "raFileProjectOther(file => $fileSource)"
Return array ref with file names of files related to \f(CW$file\fR, i.e. the
files corresponding to \f(CW$file\fR according to the .corresponding_files
config file..
.PP
Die if there is no config file.
.ie n .SS "rhRunFile(file => $fileSource, [ keyConfigCommand => ""command"" ])"
.el .SS "rhRunFile(file => \f(CW$fileSource\fP, [ keyConfigCommand => ``command'' ])"
.IX Subsection "rhRunFile(file => $fileSource, [ keyConfigCommand => command ])"
Figure out what type of source file \f(CW$fileSource\fR is, and how it should
be run.
.PP
The settings in the Project's config\->{run_file} is used to determine
the details.
.PP
Return hash ref with (keys: \*(L"dir_run_from\*(R", \*(L"command_run\*(R",
\&\*(L"type_source_file\*(R"), or die on errors (like if no Project could be
found).
.PP
dir_run_from is an absolute file name which should be the cwd when
command_run is executed.
.PP
type_source_file is something like \*(L"Test\*(R", \*(L"Module\*(R".
.ie n .SS "rhDebugFile(file => $fileSource, [ keyConfigCommand => ""command"" ])"
.el .SS "rhDebugFile(file => \f(CW$fileSource\fP, [ keyConfigCommand => ``command'' ])"
.IX Subsection "rhDebugFile(file => $fileSource, [ keyConfigCommand => command ])"
Figure out what type of source file \f(CW$fileSource\fR is, and how it should
be debugged.
.PP
The settings in the Project's config\->{debug_file} is used to determine
the details.
.PP
Return hash ref with (keys: \*(L"dir_debug_from\*(R", \*(L"command_debug\*(R",
\&\*(L"type_source_file\*(R"), or die on errors (like if no Project could be
found).
.PP
dir_debug_from is an absolute file name which should be the cwd when
command_debug is executed.
.PP
type_source_file is something like \*(L"Test\*(R", \*(L"Module\*(R".
.ie n .SS "flymakeFile(file => $fileSource)"
.el .SS "flymakeFile(file => \f(CW$fileSource\fP)"
.IX Subsection "flymakeFile(file => $fileSource)"
Do a flymake run with \f(CW$fileSource\fR according to the flymake config and
output the result to \s-1STDOUT\s0 and \s-1STDERR\s0.
.ie n .SS "rhSubCovered(file => $fileSource)"
.el .SS "rhSubCovered(file => \f(CW$fileSource\fP)"
.IX Subsection "rhSubCovered(file => $fileSource)"
Do a \*(L"covered subs\*(R" call with \f(CW$fileSource\fR in the current project.
.PP
Return hash ref with (keys: sub name; keys: quality).
.ie n .SS "createProject(dir => $dir)"
.el .SS "createProject(dir => \f(CW$dir\fP)"
.IX Subsection "createProject(dir => $dir)"
Create a new PerlySense Project in \f(CW$dir\fR.
.PP
Return 1 on success, or die on errors.
.ie n .SS "classNameAt(file => $fileOrigin, row => $row, col => $row)"
.el .SS "classNameAt(file => \f(CW$fileOrigin\fP, row => \f(CW$row\fP, col => \f(CW$row\fP)"
.IX Subsection "classNameAt(file => $fileOrigin, row => $row, col => $row)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and determine what class name that is.
.PP
Return the class name or "" if it's package main.
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "classAt(file => $fileOrigin, row => $row, col => $row)"
.el .SS "classAt(file => \f(CW$fileOrigin\fP, row => \f(CW$row\fP, col => \f(CW$row\fP)"
.IX Subsection "classAt(file => $fileOrigin, row => $row, col => $row)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and determine what
PerlySelse::Class that is.
.PP
Return the Class object or undef if it's package main.
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "classByName(name => $name, dirOrigin => $dirOrigin)"
.el .SS "classByName(name => \f(CW$name\fP, dirOrigin => \f(CW$dirOrigin\fP)"
.IX Subsection "classByName(name => $name, dirOrigin => $dirOrigin)"
Find the file that contains the Class \f(CW$name\fR, starting at \f(CW$dirOrigin\fR.
.PP
Return the Class object or undef if it couldn't be found.
.PP
Die on errors.
.ie n .SS "fileFindModule(nameModule => $nameModule, dirOrigin => $dirOrigin)"
.el .SS "fileFindModule(nameModule => \f(CW$nameModule\fP, dirOrigin => \f(CW$dirOrigin\fP)"
.IX Subsection "fileFindModule(nameModule => $nameModule, dirOrigin => $dirOrigin)"
Find the file containing the \f(CW$nameModule\fR given the \f(CW$dirOrigin\fR.
.PP
Return the absolute file name, or undef if none could be found. Die on
errors.
.ie n .SS "oDocumentFindModule(nameModule => $nameModule, dirOrigin => $dirOrigin)"
.el .SS "oDocumentFindModule(nameModule => \f(CW$nameModule\fP, dirOrigin => \f(CW$dirOrigin\fP)"
.IX Subsection "oDocumentFindModule(nameModule => $nameModule, dirOrigin => $dirOrigin)"
Find the file containing the \f(CW$nameModule\fR given the \f(CW$dirOrigin\fR.
.PP
Return a parsed PerlySense::Document, or undef if none could be
found. Die on errors.
.ie n .SS "isFileInProject(file => $fileSource, fileProjectOf => $fileProjectOf)"
.el .SS "isFileInProject(file => \f(CW$fileSource\fP, fileProjectOf => \f(CW$fileProjectOf\fP)"
.IX Subsection "isFileInProject(file => $fileSource, fileProjectOf => $fileProjectOf)"
Determine whether \f(CW$fileSource\fR is located within the current Project.
.PP
If there is no current Project, figure it out using \f(CW$fileProjectOf\fR
(that file should be located in the current project).
.PP
Return true if \f(CW$fileSource\fR is in the project, else false. Die on
errors.
.SH "IMPLEMENTATION METHODS"
.IX Header "IMPLEMENTATION METHODS"
.ie n .SS "fileFindLookingAround($fileModuleBase, $dirOrigin, $nameModule?)"
.el .SS "fileFindLookingAround($fileModuleBase, \f(CW$dirOrigin\fP, \f(CW$nameModule\fP?)"
.IX Subsection "fileFindLookingAround($fileModuleBase, $dirOrigin, $nameModule?)"
Find the file containing the \f(CW$fileModuleBase\fR given the \f(CW$dirOrigin\fR. If
\&\f(CW$nameModule\fR is specified, the file must either be in the inc_dir, or
contain a package declaration for \f(CW$nameModule\fR.
.PP
Return the file name relative to \f(CW$dirOrigin\fR, or undef if none could be
found. Die on errors.
.ie n .SS "dirFindLookingAround($fileModuleBase, $dirOrigin, [$raDirSub = [""."", ""lib"", ""bin""]])"
.el .SS "dirFindLookingAround($fileModuleBase, \f(CW$dirOrigin\fP, [$raDirSub = [``.'', ``lib'', ``bin'']])"
.IX Subsection "dirFindLookingAround($fileModuleBase, $dirOrigin, [$raDirSub = [., lib, bin]])"
Find the dir containing the \f(CW$fileModuleBase\fR (relative file path) given
the \f(CW$dirOrigin\fR. For all directories, also look in subdirectories in
\&\f(CW$raDirSub\fR.
.PP
Return the absolute dir name, or undef if none could be found. Die on
errors.
.SS "fileFindLookingInInc($fileModuleBase)"
.IX Subsection "fileFindLookingInInc($fileModuleBase)"
Find the file containing the \f(CW$nameModule\fR in config:project/extra_inc,
and \f(CW@INC\fR.
.PP
Return the absolute file name, or undef if none could be found. Die on
errors.
.SS "fileFromModule($nameModule)"
.IX Subsection "fileFromModule($nameModule)"
Return the \f(CW$nameModule\fR converted to a file name (i.e. with dirs and
\&.pm extension).
.ie n .SS "fileFoundInDir($dir, $fileModuleBase)"
.el .SS "fileFoundInDir($dir, \f(CW$fileModuleBase\fP)"
.IX Subsection "fileFoundInDir($dir, $fileModuleBase)"
Check if \f(CW$fileModuleBase\fR is located in \f(CW$dir\fR.
.PP
Return the absolute file name, or "" if not found at \f(CW$dir\fR.
.SS "textFromPod($pod)"
.IX Subsection "textFromPod($pod)"
Return \f(CW$pod\fR rendered as text, or die on errors.
.SS "oLocationRenderPodToText($oLocation)"
.IX Subsection "oLocationRenderPodToText($oLocation)"
Render the \f(CW$oLocation\fR\->rhProperty\->{pod} and put it in
rhProperty\->{text}.
.PP
Return the same (modified) \f(CW$oLocation\fR object, or undef if no
rhProperty\->{pod} property ended up as text (after this operation,
there is content in rhProperty\->{text}).
.PP
Return undef if \f(CW$oLocation\fR is undef.
.PP
Die on errors.
.ie n .SS "aDocumentFindModuleWithInterface(raNameModule => $raNameModule, raMethodRequired => $raMethodRequired, raMethodNice => $raMethodNice, dirOrigin => $dirOrigin)"
.el .SS "aDocumentFindModuleWithInterface(raNameModule => \f(CW$raNameModule\fP, raMethodRequired => \f(CW$raMethodRequired\fP, raMethodNice => \f(CW$raMethodNice\fP, dirOrigin => \f(CW$dirOrigin\fP)"
.IX Subsection "aDocumentFindModuleWithInterface(raNameModule => $raNameModule, raMethodRequired => $raMethodRequired, raMethodNice => $raMethodNice, dirOrigin => $dirOrigin)"
Return a list with Devel::PerlySense::Document objects that support
all of the methods in \f(CW$raMethodRequired\fR and possibly the methods in
\&\f(CW$raMethodNice\fR. Look in modules in \f(CW$raNameModule\fR.
.PP
The list is sorted with the best match first.
.PP
If the document APIs have one or more base classes, look in the \f(CW@ISA\fR
(depth-first, just like Perl (see perldoc perltoot)).
.PP
Warn on some failures to find the location. Die on errors.
.ie n .SS "aApiOfClass(file => $fileOrigin, row => $row, col => $row)"
.el .SS "aApiOfClass(file => \f(CW$fileOrigin\fP, row => \f(CW$row\fP, col => \f(CW$row\fP)"
.IX Subsection "aApiOfClass(file => $fileOrigin, row => $row, col => $row)"
Look in \f(CW$file\fR at location \f(CW$row\fR/$col and determine what package is
there.
.PP
Return a two item array with (Package name,
Devel::PerlySense::Document::Api object with the likely \s-1API\s0 of that
class), or () if none was found.
.PP
Die if \f(CW$file\fR doesn't exist, or on other errors.
.ie n .SS "aDocumentGrepInDir(dir => $dir, rsGrepFile => $rsGrepFile, rsGrepDocument => $rsGrepDocument)"
.el .SS "aDocumentGrepInDir(dir => \f(CW$dir\fP, rsGrepFile => \f(CW$rsGrepFile\fP, rsGrepDocument => \f(CW$rsGrepDocument\fP)"
.IX Subsection "aDocumentGrepInDir(dir => $dir, rsGrepFile => $rsGrepFile, rsGrepDocument => $rsGrepDocument)"
Return a list with Devel::PerlySense::Document objects found under the
\&\f(CW$dir\fR, and that return true for the grep sub \f(CW$rsGrepFile\fR and \f(CW$rsGrepDocument\fR.
.PP
If any found file couldn't be parsed, skip it silently from the list.
.SH "CACHE METHODS"
.IX Header "CACHE METHODS"
.ie n .SS "cacheSet(file => $file, key => $key, value => $valuex)"
.el .SS "cacheSet(file => \f(CW$file\fP, key => \f(CW$key\fP, value => \f(CW$valuex\fP)"
.IX Subsection "cacheSet(file => $file, key => $key, value => $valuex)"
If the oCache isn't undef, store the \f(CW$value\fR in the cache under the
total key of ($file, \f(CW$file\fR's timestamp, \f(CW$key\fR, and the PerlySense
\&\s-1VERSION\s0).
.PP
\&\f(CW$value\fR should be a scalar or reference which can be freezed.
.PP
\&\f(CW$file\fR must be an existing file.
.PP
Return 1 if the \f(CW$value\fR was stored, else 0. Die on errors.
.ie n .SS "cacheGet(file => $file, key => $key)"
.el .SS "cacheGet(file => \f(CW$file\fP, key => \f(CW$key\fP)"
.IX Subsection "cacheGet(file => $file, key => $key)"
If the oCache isn't undef, get the value in the cache under the total
key of ($file, \f(CW$file\fR's timestamp, \f(CW$key\fR) and return it.
.PP
\&\f(CW$file\fR must be an existing file.
.PP
Return the value, or undef if the value could not be fetched. Die on errors.
.ie n .SS "cacheKeyTotal($file, $key)"
.el .SS "cacheKeyTotal($file, \f(CW$key\fP)"
.IX Subsection "cacheKeyTotal($file, $key)"
If oCache is undef, return undef.
.PP
Otherwise, return the total key of ($file, \f(CW$file\fR's timestamp, \f(CW$key\fR,
and the PerlySense \s-1VERSION\s0).
.PP
\&\f(CW$file\fR must be an existing file.
.PP
Die on errors.
